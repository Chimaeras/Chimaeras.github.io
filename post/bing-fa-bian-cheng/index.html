<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>并发编程 | Joker&#39;s Blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://chimaeras.ltd/favicon.ico?v=1633700876230">
<link rel="stylesheet" href="https://chimaeras.ltd/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="四星

三星
什么是进程？什么是线程？
线程是处理器任务调度和执行的基本单位，进程是操作系统资源分配的基本单位。
进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进程可以包含多个线程。

线程死锁是如何产..." />
    <meta name="keywords" content="总结" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://chimaeras.ltd">
        <img src="https://chimaeras.ltd/images/avatar.png?v=1633700876230" class="site-logo">
        <h1 class="site-title">Joker&#39;s Blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Chimaeras" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://chimaeras.ltd/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">并发编程</h2>
            <div class="post-date">2021-10-08</div>
            
            <div class="post-content" v-pre>
              <h2 id="四星">四星</h2>
<hr>
<h2 id="三星">三星</h2>
<h3 id="什么是进程什么是线程">什么是进程？什么是线程？</h3>
<p>线程是处理器任务调度和执行的基本单位，进程是操作系统资源分配的基本单位。</p>
<p>进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进程可以包含多个线程。</p>
<hr>
<h3 id="线程死锁是如何产生的如何避免">线程死锁是如何产生的，如何避免</h3>
<p>死锁：由于两个或两个以上的线程相互竞争对方的资源，而同时不释放自己的资源，导致所有线程同时被阻塞。</p>
<p>死锁产生的条件：</p>
<ul>
<li>互斥条件：一个资源在同一时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程在请求被占资源时发生阻塞，并对已获得的资源保持不放。</li>
<li>循环等待条件：发生死锁时，所有的线程会形成一个死循环，一直阻塞。</li>
<li>不剥夺条件：线程已获得的资源在未使用完不能被其他线程剥夺，只能由自己使用完释放资源。</li>
</ul>
<p>避免死锁的方法主要是破坏死锁产生的条件。</p>
<ul>
<li>
<p>破坏互斥条件：这个条件无法进行破坏，锁的作用就是使他们互斥。</p>
</li>
<li>
<p>破坏请求与保持条件：一次性申请所有的资源。</p>
</li>
<li>
<p>破坏循环等待条件：按顺序来申请资源。</p>
</li>
<li>
<p>破坏不剥夺条件：线程在申请不到所需资源时，主动放弃所持有的资源。</p>
</li>
</ul>
<pre><code class="language-java">// 死锁示例
class DeadLockDemo {
    private static Object resource1 = new Object();
    private static Object resource2 = new Object();
 
    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000);   //线程休眠，保证线程2先获得资源2
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 1&quot;).start();
 
        new Thread(() -&gt; {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                try {
                    Thread.sleep(1000); //线程休眠，保证线程1先获得资源1
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                }
            }
        }, &quot;线程 2&quot;).start();
    }
}

// Thread[线程 1,5,main]get resource1
// Thread[线程 2,5,main]waiting get resource1
// Thread[线程 1,5,main]waiting get resource2
</code></pre>
<p>线程1获取到了资源1，线程2获取到了资源2，线程1继续获取资源2而产生阻塞，线程2继续获取资源1而产生阻塞。</p>
<p>解决办法为：按照顺序获取资源。</p>
<p>线程1和线程2都先获取资源1再获取资源2，无论哪个线程先获取到资源1，另一个线程都会因无法获取线程1产生阻塞，等到先获取到资源1的线程释放资源1，另一个线程获取资源1，这样两个线程可以轮流获取资源1和资源2。</p>
<pre><code class="language-java"> 	private static Object resource1 = new Object();
    private static Object resource2 = new Object();
 
    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000); 
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 1&quot;).start();
 
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 2&quot;).start();
    }
}
</code></pre>
<hr>
<h3 id="进程和线程的关系区别">进程和线程的关系？（区别）</h3>
<p>定义：线程是处理器任务调度和执行的基本单位；进程是操作系统资源分配的基本单位。</p>
<p>包含关系：一个进程可以包含多个线程。</p>
<p>从Java虚拟机的角度来理解：Java虚拟机的运行时数据区包含堆（共享）、方法区（共享）、虚拟机栈、本地方法栈、程序计数器。各个进程之间是相互独立的，每个进程会包含多个线程，每个进程所包含的多个线程并不是相互独立的，这个线程会共享进程的堆和方法区，但这些线程不会共享虚拟机栈、本地方法栈、程序计数器。即每个进程所包含的多个线程共享进程的堆和方法区，并且具备私有的虚拟机栈、本地方法栈、程序计数器。</p>
<p>区别：</p>
<ul>
<li>内存分配：进程之间的地址空间和资源是相互独立的，同一个进程之间的线程会共享线程的地址空间和资源（堆和方法区）。</li>
<li>资源开销：每个进程具备各自的数据空间，进程之间的切换会有较大的开销。属于同一进程的线程会共享堆和方法区，同时具备私有的虚拟机栈、本地方法栈、程序计数器，线程之间的切换资源开销较小。</li>
</ul>
<hr>
<h3 id="线程的生命周期和状态">线程的生命周期和状态</h3>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>new</td>
<td>初始状态，<strong>注意此时还未调用<code>start()</code>方法</strong></td>
</tr>
<tr>
<td>runnable</td>
<td>运行状态，包含就绪和运行中两种状态</td>
</tr>
<tr>
<td>blocked</td>
<td>阻塞状态</td>
</tr>
<tr>
<td>waiting</td>
<td>等待状态</td>
</tr>
<tr>
<td>time_waiting</td>
<td>超时等待状态，和等待状态不同的是，它可以在制定的时间自行返回</td>
</tr>
<tr>
<td>terminated</td>
<td>终止状态，线程运行结束</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="创建线程一共有哪几种方法">创建线程一共有哪几种方法？</h3>
<ul>
<li>继承<code>Thread</code>类创建线程</li>
<li>实现<code>Runnable</code>接口创建线程</li>
<li>使用<code>Callable</code>和<code>Future</code>创建线程</li>
<li>使用线程池例如用<code>Executor</code>框架</li>
</ul>
<p><strong>继承Thread类创建线程</strong>，首先继承Thread类，重写<code>run()</code>方法，在<code>main()</code>函数中调用子类实实例的<code>start()</code>方法。</p>
<pre><code class="language-java">public class ThreadDemo extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行&quot;);
    }
}

public class TheadTest {
    public static void main(String[] args) {
        ThreadDemo threadDemo = new ThreadDemo();     
        threadDemo.start();
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行结束&quot;);
    }
}

// main main()方法执行结束
// Thread-0 run()方法正在执行
</code></pre>
<p>**实现Runnable接口创建线程：**首先创建实现<code>Runnable</code>接口的类<code>RunnableDemo</code>，重写<code>run()</code>方法；创建类<code>RunnableDemo</code>的实例对象<code>runnableDemo</code>，以<code>runnableDemo</code>作为参数创建<code>Thread</code>对象，调用<code>Thread</code>对象的<code>start()</code>方法。</p>
<pre><code class="language-java">public class RunnableDemo implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中&quot;);
    }
}

public class RunnableTest {
    public static void main(String[] args) {
        RunnableDemo  runnableDemo = new RunnableDemo ();
        Thread thread = new Thread(runnableDemo);
        thread.start();
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);
}
    
// main main()方法执行完成
// Thread-0 run()方法执行中
</code></pre>
<p><strong>使用Callable和Future创建线程：</strong></p>
<ol>
<li>创建Callable接口的实现类<code>CallableDemo</code>，重写<code>call()</code>方法。</li>
<li>以类<code>CallableDemo</code>的实例化对象作为参数创建<code>FutureTask</code>对象。</li>
<li>以<code>FutureTask</code>对象作为参数创建<code>Thread</code>对象。</li>
<li>调用<code>Thread</code>对象的<code>start()</code>方法。</li>
</ol>
<pre><code class="language-java">class CallableDemo implements Callable&lt;Integer&gt; {    
    @Override    
    public Integer call() {        
        System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中&quot;);        
        return 0;    
    }
} 
class CallableTest {    
    public static void main(String[] args) throws ExecutionException, InterruptedException {  
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new CallableDemo());        
        Thread thread = new Thread(futureTask);        
        thread.start();        
        System.out.println(&quot;返回结果 &quot; + futureTask.get());        
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);    
    }
}

// Thread-0 call()方法执行中
// 返回结果 0 
// main main()方法执行完成

</code></pre>
<p><strong>使用线程池例如用Executor框架：</strong> <code>Executors</code>可提供四种线程池，分别为：</p>
<ul>
<li><code>newCachedThreadPool</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li><code>newFixedThreadPool</code> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li><code>newScheduledThreadPool</code> 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li><code>newSingleThreadExecutor</code> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li>
</ul>
<pre><code class="language-java">class ThreadDemo extends Thread {    
    @Override    
    public void run() {        
        System.out.println(Thread.currentThread().getName() + &quot;正在执行&quot;);    
    }
}

class TestFixedThreadPool {        
    public static void main(String[] args) {        
        //创建一个可重用固定线程数的线程池        
        ExecutorService pool = Executors.newFixedThreadPool(2);        
        //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口        
        Thread t1 = new ThreadDemo();        
        Thread t2 = new ThreadDemo();        
        Thread t3 = new ThreadDemo();        
        Thread t4 = new ThreadDemo();        
        Thread t5 = new ThreadDemo();        
        //将线程放入池中进行执行        
        pool.execute(t1);        
        pool.execute(t2);        
        pool.execute(t3);        
        pool.execute(t4);        
        pool.execute(t5);        
        //关闭线程池        
        pool.shutdown();        
    }        
}

// pool-1-thread-2正在执行
// pool-1-thread-1正在执行
// pool-1-thread-1正在执行
// pool-1-thread-2正在执行
// pool-1-thread-1正在执行
</code></pre>
<hr>
<h3 id="runnable-和-callable-有什么区别">runnable 和 callable 有什么区别？</h3>
<p>相同点：</p>
<ul>
<li>两者都是接口</li>
<li>两者都需要调用<code>Thread.start</code>启动线程</li>
</ul>
<p>不同点：</p>
<ul>
<li>callable的核心是<code>call()</code>方法，允许返回值，<code>runnable</code>的核心是<code>run()</code>方法，没有返回值</li>
<li><code>call()</code>方法可以抛出异常，但是<code>run()</code>方法不行</li>
<li><code>callable</code>和<code>runnable</code>都可以应用于<code>executors</code>，<code>thread</code>类只支持<code>runnable</code></li>
</ul>
<hr>
<h3 id="线程的run和start有什么区别">线程的run()和start()有什么区别？</h3>
<ul>
<li>线程是通过<code>Thread</code>对象所对应的方法<code>run()</code>来完成其操作的，而线程的启动是通过<code>start()</code>方法执行的。</li>
<li><code>run()</code>方法可以重复调用，<code>start()</code>方法只能调用一次</li>
</ul>
<hr>
<h3 id="为什么调用start方法时会执行run方法而不直接执行run方法">为什么调用start()方法时会执行run()方法，而不直接执行run()方法？</h3>
<p><code>start()</code>方法来启动线程，真正实现了多线程运行，这时无需等待<code>run()</code>方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 <code>start()</code>方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行<code>run()</code>方法，这里方法<code>run()</code>称为线程体，它包含了要执行的这个线程的内容，<code>run()</code>方法运行结束，此线程随即终止。</p>
<p><code>run()</code>方法只是类的一个普通方法而已，如果直接调用<code>run</code>方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待<code>run()</code>方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>调用<code>start()</code>方法可以开启一个线程，而<code>run()</code>方法只是thread类中的一个普通方法，直接调用<code>run()</code>方法还是在主线程中执行的。</p>
<hr>
<h3 id="线程同步以及线程调度相关的方法有哪些">线程同步以及线程调度相关的方法有哪些？</h3>
<p><code>wait()</code>：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p>
<p><code>sleep()</code>：使当前线程进入指定毫秒数的休眠，暂停执行，需要处理<code>InterruptedException</code>。</p>
<p><code>notify()</code>：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。</p>
<p><code>notifyAll()</code>：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。</p>
<p><code>join()</code>：与<code>sleep()</code>方法一样，是一个可中断的方法，在一个线程中调用另一个线程的<code>join()</code>方法，会使得当前的线程挂起，直到执行<code>join()</code>方法的线程结束。例如在B线程中调用A线程的<code>join()</code>方法，B线程进入阻塞状态，直到A线程结束或者到达指定的时间。</p>
<p><code>yield()</code>：提醒调度器愿意放弃当前的CPU资源，使得当前线程从<code>RUNNING</code>状态切换到<code>RUNABLE</code>状态。</p>
<hr>
<h3 id="线程的sleep方法和yield方法有什么不同">线程的sleep()方法和yield()方法有什么不同？</h3>
<p><code>sleep()</code>方法使得当前线程暂停指定的时间，没有消耗CPU时间片。</p>
<p><code>sleep()</code>使得线程进入到阻塞状态，<code>yield()</code>只是对CPU进行提示，如果CPU没有忽略这个提示，会使得线程上下文的切换，进入到就绪状态。</p>
<p><code>sleep()</code>一定会完成给定的休眠时间，<code>yield()</code>不一定能完成。</p>
<p><code>sleep()</code>需要抛出InterruptedException，而<code>yield()</code>方法无需抛出异常。</p>
<hr>
<h3 id="sleep方法和wait方法的区别">sleep()方法和wait()方法的区别？</h3>
<p>相同点：</p>
<ul>
<li><code>wait()</code>方法和<code>sleep()</code>方法都可以使得线程进入到阻塞状态。</li>
<li><code>wait()</code>和<code>sleep()</code>方法都是可中断方法，被中断后都会收到中断异常。</li>
</ul>
<p>不同点：</p>
<ul>
<li><code>wait()</code>是Object的方法，<code>sleep()</code>是Thread的方法。</li>
<li><code>wait()</code>必须在同步方法中进行，<code>sleep()</code>方法不需要。</li>
<li>线程在同步方法中执行<code>sleep()</code>方法，不会释放monitor的锁，而<code>wait()</code>方法会释放monitor的锁。</li>
<li><code>sleep()</code>方法在短暂的休眠之后会主动退出阻塞，而<code>wait()</code>方法在没有指定wait时间的情况下需要被其他线程中断才可以退出阻塞。</li>
</ul>
<hr>
<h3 id="wait方法一般在循环块中使用还是if块中使用">wait()方法一般在循环块中使用还是if块中使用？</h3>
<p>在JDK官方文档中明确要求了要在循环中使用，否则可能出现虚假唤醒的可能。官方文档中给出的代码示例如下：</p>
<pre><code class="language-java">synchronized(obj){    
    while(&lt;condition does not hold&gt;){         
        obj.wait();   
    }    //满足while中的条件后执行业务逻辑
}
</code></pre>
<p>如果讲<code>while</code>换成<code>if</code>：</p>
<pre><code class="language-java">synchronized(obj){    
	if(&lt;condition does not hold&gt;){         
		obj.wait();    
	}    
	//满足while中的条件后执行业务逻辑
}
</code></pre>
<p>当线程被唤醒后，可能<code>if()</code>中的条件已经不满足了，出现虚假唤醒。</p>
<hr>
<h3 id="线程通信的方法有哪些">线程通信的方法有哪些？</h3>
<ul>
<li>锁与同步</li>
<li><code>wait()</code>/<code>notify()</code>或<code>notifyAll()</code></li>
<li>信号量</li>
<li>管道</li>
</ul>
<hr>
<h3 id="什么是线程同步什么是线程互斥他们是如何实现的">什么是线程同步？什么是线程互斥？他们是如何实现的？</h3>
<ul>
<li>线程的互斥是指某一个资源只能被一个访问者访问，具有唯一性和排他性。但访问者对资源访问的顺序是乱序的。</li>
<li>线程的同步是指在互斥的基础上使得访问者对资源进行有序访问。</li>
</ul>
<p>线程同步的实现方法：</p>
<ul>
<li>同步方法</li>
<li>同步代码块</li>
<li><code>wait()</code>和<code>notify()</code></li>
<li>使用volatile实现线程同步</li>
<li>使用重入锁实现线程同步</li>
<li>使用局部变量实现线程同步</li>
<li>使用阻塞队列实现线程同步</li>
</ul>
<hr>
<h3 id="在java程序中如何保证线程的运行安全">在Java程序中如何保证线程的运行安全？</h3>
<p>线程安全问题 主要体现在原子性、可见性和有序性。</p>
<ul>
<li>原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性。线程切换带来的原子性问题。</li>
<li>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。缓存导致的可见性问题。</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行。编译优化带来的有序性问题。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>原子性问题：可用JDK <code>Atomic</code>开头的原子类、<code>synchronized</code>、<code>LOCK</code>来解决</li>
<li>可见性问题：可用<code>synchronized</code>、<code>volatile</code>、<code>LOCK</code>来解决</li>
<li>有序性问题：可用<code>Happens-Before</code> 规则来解决</li>
</ul>
<hr>
<h3 id="三个线程t1-t2-t3如何让他们按顺序执行">三个线程T1、T2、T3，如何让他们按顺序执行？</h3>
<p>这是一道面试中常考的并发编程的代码题，与它相似的问题有：</p>
<ul>
<li>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC.......</li>
<li>两个线程交替打印1-100的奇偶数</li>
<li>N个线程循环打印1-100</li>
<li>......</li>
</ul>
<p>其实这类问题本质上都是线程通信问题，思路基本上都是一个线程执行完毕，阻塞该线程，唤醒其他线程，按顺序执行下一个线程。下面先来看最简单的，如何按顺序执行三个线程。</p>
<ul>
<li>synchronized+wait/notify</li>
</ul>
<p>基本思路就是线程A、线程B、线程C三个线程同时启动，因为变量<code>num</code>的初始值为<code>0</code>，所以线程B或线程C拿到锁后，进入<code>while()</code>循环，然后执行<code>wait()</code>方法，线程线程阻塞，释放锁。只有线程A拿到锁后，不进入<code>while()</code>循环，执行<code>num++</code>，打印字符<code>A</code>，最后唤醒线程B和线程C。此时<code>num</code>值为<code>1</code>，只有线程B拿到锁后，不被阻塞，执行<code>num++</code>，打印字符<code>B</code>，最后唤醒线程A和线程C，后面以此类推。</p>
<pre><code class="language-java">class Wait_Notify_ACB {        private int num;        private static final Object LOCK = new Object();        private void printABC(String name, int targetNum) {                    synchronized (LOCK) {                            while (num % 3 != targetNum) {                    //想想这里为什么不能用if代替while，想不起来可以看上一篇文章                                    try {                                            LOCK.wait();                                    } catch (InterruptedException e) {                                            e.printStackTrace();                                    }                            }                            num++;                            System.out.print(name);                            LOCK.notifyAll();                    }        }                public static void main(String[] args) {                Wait_Notify_ACB  wait_notify_acb = new Wait_Notify_ACB ();                new Thread(() -&gt; {                        wait_notify_acb.printABC(&quot;A&quot;, 0);                }, &quot;A&quot;).start();                new Thread(() -&gt; {                        wait_notify_acb.printABC(&quot;B&quot;, 1);                }, &quot;B&quot;).start();                new Thread(() -&gt; {                        wait_notify_acb.printABC(&quot;C&quot;, 2);                }, &quot;C&quot;).start();        }}
</code></pre>
<p>接下来看看第一个问题，三个线程T1、T2、T3轮流打印ABC，打印n次。其实只需要将上述代码加一个循环即可，这里假设n=10。</p>
<pre><code class="language-java">class Wait_Notify_ACB {        private int num;        private static final Object LOCK = new Object();        private void printABC(String name, int targetNum) {                for (int i = 0; i &lt; 10; i++) {                        synchronized (LOCK) {                                while (num % 3 != targetNum) {                     //想想这里为什么不能用if代替，想不起来可以看上一篇文章                                        try {                                                LOCK.wait();                                        } catch (InterruptedException e) {                                                e.printStackTrace();                                        }                                }                                num++;                                System.out.print(name);                                LOCK.notifyAll();                        }                }        }                public static void main(String[] args) {                Wait_Notify_ACB  wait_notify_acb = new Wait_Notify_ACB ();                new Thread(() -&gt; {                        wait_notify_acb.printABC(&quot;A&quot;, 0);                }, &quot;A&quot;).start();                new Thread(() -&gt; {                        wait_notify_acb.printABC(&quot;B&quot;, 1);                }, &quot;B&quot;).start();                new Thread(() -&gt; {                        wait_notify_acb.printABC(&quot;C&quot;, 2);                }, &quot;C&quot;).start();        }}
</code></pre>
<p>下面看第二个问题，两个线程交替打印1-100的奇偶数，为了减少输入所占篇幅，这里将100 改成了10。基本思路上面类似，线程odd先拿到锁——打印数字——唤醒线程even——阻塞线程odd，以此循环。</p>
<pre><code class="language-java">class  Wait_Notify_Odd_Even{        private Object monitor = new Object();        private volatile int count;        Wait_Notify_Odd_Even(int initCount) {                this.count = initCount;        }        private void printOddEven() {                synchronized (monitor) {                        while (count &lt; 10) {                                try {                                        System.out.print( Thread.currentThread().getName() + &quot;：&quot;);                                        System.out.println(++count);                                        monitor.notifyAll();                                        monitor.wait();                                } catch (InterruptedException e) {                                        e.printStackTrace();                                }                        }                        //防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出                        monitor.notifyAll();                }        }            public static void main(String[] args) throws InterruptedException {                Wait_Notify_Odd_Even waitNotifyOddEven = new Wait_Notify_Odd_Even(0);                new Thread(waitNotifyOddEven::printOddEven, &quot;odd&quot;).start();                Thread.sleep(10);                new Thread(waitNotifyOddEven::printOddEven, &quot;even&quot;).start();        }}
</code></pre>
<p>面试官：大家都是用的synchronized+wait/notify，你能不能换个方法解决该问题？</p>
<p>我：好的，我还会用join方法</p>
<p><code>join()</code>方法：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。代码如下：</p>
<pre><code class="language-java">class Join_ABC {        public static void main(String[] args) throws InterruptedException {                for (int i = 0; i &lt; 10; i++) {                        Thread t1 = new Thread(new printABC(null),&quot;A&quot;);                        Thread t2 = new Thread(new printABC(t1),&quot;B&quot;);                        Thread t3 = new Thread(new printABC(t2),&quot;C&quot;);                        t0.start();                        t1.start();                        t2.start();                        Thread.sleep(10);             //这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。                }        }        static class printABC implements Runnable{                private Thread beforeThread;                public printABC(Thread beforeThread) {                        this.beforeThread = beforeThread;                }                @Override                public void run() {                        if(beforeThread!=null) {                                try {                                        beforeThread.join();                                        System.out.print(Thread.currentThread().getName());                                }catch(Exception e){                                        e.printStackTrace();                                }                        }else {                                System.out.print(Thread.currentThread().getName());                        }                }        }}
</code></pre>
<p>面试官：还会其他方法吗？</p>
<p>我：还会Lock。</p>
<p>该方法很容易理解，其实现代码和synchronized+wait/notify方法的很像。不管哪个线程拿到锁，只有符合条件的才能打印。代码如下：</p>
<pre><code class="language-java"> class Lock_ABC {         private int num;        // 当前状态值：保证三个线程之间交替打印         private Lock lock = new ReentrantLock();         private void printABC(String name, int targetNum) {                 for (int i = 0; i &lt; 10; ) {                         lock.lock();                         if (num % 3 == targetNum) {                                 num++;                                 i++;                                 System.out.print(name);                         }                         lock.unlock();                 }         }         public static void main(String[] args) {                 Lock_ABC lockABC = new Lock_ABC();                 new Thread(() -&gt; {                         lockABC.printABC(&quot;A&quot;, 0);                 }, &quot;A&quot;).start();                 new Thread(() -&gt; {                         lockABC.printABC(&quot;B&quot;, 1);                 }, &quot;B&quot;).start();                 new Thread(() -&gt; {                         lockABC.printABC(&quot;C&quot;, 2);                 }, &quot;C&quot;).start();         } }
</code></pre>
<p>面试官：该方法存在什么问题，可以进一步优化吗</p>
<p>我：可以使用Lock+Condition实现对线程的精准唤醒，减少对其他线程无意义地唤醒，浪费资源。</p>
<ul>
<li>Lock+Condition</li>
</ul>
<p>该思路和synchronized+wait/notify方法的更像了，synchronized对应lock，await/signal方法对应wait/notify方法。下面的代码为了能精准地唤醒下一个线程，创建了多个Condition对象。</p>
<pre><code class="language-java">class LockConditionABC {        private int num;        private static Lock lock = new ReentrantLock();        private static Condition c1 = lock.newCondition();        private static Condition c2 = lock.newCondition();        private static Condition c3 = lock.newCondition();        private void printABC(String name, int targetNum, Condition currentThread, Condition nextThread) {                for (int i = 0; i &lt; 10; ) {                        lock.lock();                        try {                                while (num % 3 != targetNum) {                                        currentThread.await();                                }                                num++;                                i++;                                System.out.print(name);                                nextThread.signal();                        } catch (Exception e) {                                e.printStackTrace();                        } finally {                                lock.unlock();                        }                }        }        public static void main(String[] args) {                LockConditionABC print = new LockConditionABC();                new Thread(() -&gt; {                        print.printABC(&quot;A&quot;, 0, c1, c2);                }, &quot;A&quot;).start();                new Thread(() -&gt; {                        print.printABC(&quot;B&quot;, 1, c2, c3);                }, &quot;B&quot;).start();                new Thread(() -&gt; {                        print.printABC(&quot;C&quot;, 2, c3, c1);                }, &quot;C&quot;).start();        }}
</code></pre>
<p>面试官：除了该方法，还有什么方法可以避免唤醒其他无意义的线程？</p>
<p>我：可以通过使用信号量来实现。</p>
<ul>
<li>Semaphore</li>
</ul>
<p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p>
<p>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。</p>
<p>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p>
<pre><code class="language-java">class SemaphoreABC {        private static Semaphore s1 = new Semaphore(1);      //先打印A，所以设s1中的计数器值为1        private static Semaphore s2 = new Semaphore(0);        private static Semaphore s3 = new Semaphore(0);            private void printABC(String name, Semaphore currentThread, Semaphore nextThread) {                for (int i = 0; i &lt; 10; i++) {                        try {                                currentThread.acquire();                   //阻塞当前线程，即调用当前线程acquire()，计数器减1为0                                System.out.print(name);                                nextThread.release();                    //唤醒下一个线程，即调用下一个线程线程release()，计数器加1                        } catch (InterruptedException e) {                                e.printStackTrace();                        }                }        }        public static void main(String[] args) throws InterruptedException {                SemaphoreABC printer = new SemaphoreABC();                new Thread(() -&gt; {                        printer.printABC(&quot;A&quot;, s1, s2);                }, &quot;A&quot;).start();                Thread.sleep(10);                new Thread(() -&gt; {                        printer.printABC(&quot;B&quot;, s2, s3);                }, &quot;B&quot;).start();                Thread.sleep(10);                new Thread(() -&gt; {                        printer.printABC(&quot;C&quot;, s3, s1);                }, &quot;C&quot;).start();        }}
</code></pre>
<hr>
<h2 id="两星">两星</h2>
<h3 id="多线程的优缺点为什么使用多线程-多线程会引发什么问题">多线程的优缺点（为什么使用多线程、多线程会引发什么问题）</h3>
<p>优点：当一个线程进入等待状态或者阻塞时，CPU可以先去执行其他线程，提高CPU的利用率。</p>
<p>缺点：</p>
<ul>
<li>上下文切换：频繁的上下文切换会影响多线程的执行速度。</li>
<li>死锁</li>
<li>资源限制：在进行并发编程时，程序的执行速度受限于计算机的硬件或软件资源。在并发编程中，程序执行变快的原因是将程序中串行执行的部分变成并发执行，如果因为资源限制，并发执行的部分仍在串行执行，程序执行将会变得更慢，因为程序并发需要上下文切换和资源调度。</li>
</ul>
<hr>
<h3 id="为什么wait-notify-notifyall被定义在object类中而不是在thread类中">为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？</h3>
<p>因为这些方法在操作同步线程时，都必须要标识他们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的<code>notify()</code>或<code>notifyAll()</code>唤醒，不可以对不同锁中的线程进行唤醒，也就是说等待和唤醒必须是同一锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在<code>Object</code>类中。</p>
<p>如果把<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>定义在Thread类中，则会出现一些难以解决的问题，例如如何让一个线程可以持有多把锁？如何确定线程等待的是哪把锁？既然是当前线程去等待某个对象的锁，则应通过操作对象来实现而不是操作线程，而Object类是所有对象的父类，所以将这三种方法定义在Object类中最合适。</p>
<hr>
<h3 id="为什么waitnotify和notifyall必须在同步方法或者同步块中被调用">为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3>
<p>因为<code>wait()</code>暂停的是持有锁的对象，<code>notify()</code>或<code>notifyAll()</code>唤醒的是等待锁的对象。所以<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>都需要线程持有锁的对象，进而需要在同步方法或者同步块中被调用。</p>
<hr>
<h3 id="如何停止一个正在运行的线程">如何停止一个正在运行的线程？</h3>
<ul>
<li>中断：<code>Interrupt</code>方法中断线程</li>
<li>使用<code>volatile boolean</code>标志位停止线程：在线程中设置一个<code>boolean</code>标志位，同时用<code>volatile</code>修饰保证可见性，在线程里不断地读取这个值，其他地方可以修改这个<code>boolean</code>值。</li>
<li>使用<code>stop()</code>方法停止线程，但该方法已经被废弃。因为这样线程不能在停止前保存数据，会出现数据完整性问题。</li>
</ul>
<hr>
<h3 id="如何唤醒一个阻塞的线程">如何唤醒一个阻塞的线程？</h3>
<p>如果线程是由于<code>wait()</code>、<code>sleep()</code>、<code>join()</code>、<code>yield()</code>等方法进入阻塞状态的，是可以进行唤醒的。如果线程是IO阻塞是无法进行唤醒的，因为IO是操作系统层面的，Java代码无法直接接触操作系统。</p>
<ul>
<li><code>wait()</code>：可用<code>notify()</code>或<code>notifyAll()</code>方法唤醒。</li>
<li><code>sleep()</code>：调用该方法使得线程在指定时间内进入阻塞状态，等到指定时间过去，线程再次获取到CPU时间片进而被唤醒。</li>
<li><code>join()</code>：当前线程A调用另一个线程B的<code>join()</code>方法，当前线程转A入阻塞状态，直到线程B运行结束，线程A才由阻塞状态转为可执行状态。</li>
<li><code>yield()</code>：使得当前线程放弃CPU时间片，但随时可能再次得到CPU时间片进而激活。</li>
</ul>
<hr>
<h3 id="java如何实现两个线程之间的通信和协作">Java如何实现两个线程之间的通信和协作？</h3>
<p>syncrhoized<code>加锁的线程的</code>Object<code>类的</code>wait()<code>/</code>notify()<code>/</code>notifyAll()<br>
ReentrantLock<code>类加锁的线程的</code>Condition<code>类的</code>await()<code>/</code>signal()<code>/</code>signalAll()</p>
<p>通过管道进行线程间通信：1）字节流；2）字符流 ，就是一个线程发送数据到输出管道，另一个线程从输入管道读数据。</p>
<hr>
<h3 id="同步方法和同步方法块哪个效果更好">同步方法和同步方法块哪个效果更好？</h3>
<p>同步块更好些，因为它锁定的范围更灵活些，只在需要锁住的代码块锁住相应的对象，而同步方法会锁住整个对象。</p>
<hr>
<h2 id="一星">一星</h2>
<h3 id="并行和并发的区别">并行和并发的区别？</h3>
<p>并行：单位时间多个处理器同时处理多个任务。</p>
<p>并发：一个处理器处理多个任务，按时间片轮流处理多个任务。</p>
<hr>
<h3 id="线程的上下文切换">线程的上下文切换</h3>
<p>即便是单核的处理器也会支持多线程，处理器会给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。</p>
<p>CPU会通过时间片分配<a href="">算法</a>来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，从任务保存到在加载的过程就是一次上下文切换。</p>
<hr>
<h3 id="java中守护线程和用户线程的区别">Java中守护线程和用户线程的区别？</h3>
<p>任何线程都可以设置为守护线程和用户线程，通过方法<code>Thread.setDaemon(bool on)</code> 设置，<code>true</code>则是将该线程设置为守护线程，<code>false</code>则是将该线程设置为用户线程。同时，<code>Thread.setDaemon()</code>必须在<code>Thread.start()</code>之前调用，否则运行时会抛出异常。</p>
<p>用户线程：平时使用到的线程均为用户线程。</p>
<p>守护线程：用来服务用户线程的线程，例如垃圾回收线程。</p>
<p>区别：主要在于Java虚拟机是否存活。</p>
<ul>
<li>
<p>用户线程：当任何一个用户线程未结束，Java虚拟机是不会结束的。</p>
</li>
<li>
<p>守护线程：如果只剩守护线程未结束，Java虚拟机结束。</p>
</li>
</ul>
<hr>
<h3 id="java中的死锁-活锁-饥饿有什么区别">Java中的死锁、活锁、饥饿有什么区别</h3>
<p>活锁：任务或者执行者没有被阻塞，由于某些条件没有被满足，导致线程一直重复尝试、失败、尝试、失败。例如，线程1和线程2都需要获取一个资源，但他们同时让其他线程先获取该资源，两个线程一直谦让，最后都无法获取</p>
<p>活锁和死锁的区别：</p>
<ul>
<li>活锁是在不断地尝试、死锁是在一直等待。</li>
<li>活锁有可能自行解开、死锁无法自行解开。</li>
</ul>
<p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。以打印机打印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。活锁就是在忙式等待条件下发生的饥饿，忙式等待就是不进入等待状态的等待。</p>
<p>产生饥饿的原因：</p>
<ul>
<li>高优先级的线程占用了低优先级线程的CPU时间</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的<code>wait()</code>方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<p>死锁、饥饿的区别：饥饿可自行解开，死锁不行。</p>
<hr>
<h3 id="为什么thread类的sleep和yield方法是静态的">为什么Thread类的sleep()和yield()方法是静态的？</h3>
<p><code>sleep()</code>和<code>yield()</code>都是需要正在执行的线程调用的，那些本来就阻塞或者等待的线程调用这个方法是无意义的，所以这两个方法是静态的。</p>
<hr>
<h3 id="线程类的构造方法-静态块是被哪个线程调用的">线程类的构造方法、静态块是被哪个线程调用的？</h3>
<p>线程类的构造方法、静态块是被<code>new</code>这个线程类所在的线程所调用的，而<code>run()</code>方法里面的代码才是被线程自身所调用的。</p>
<p>一个很经典的例子：</p>
<p>假设<code>main()</code>函数中<code>new</code>了一个线程Thread1，那么Thread1的构造方法、静态块都是<code>main</code>线程调用的，Thread1中的<code>run()</code>方法是自己调用的。</p>
<p>假设在Thread1中<code>new</code>了一个线程Thread2，那么Thread2的构造方法、静态块都是Thread1线程调用的，Thread2中的<code>run()</code>方法是自己调用的。</p>
<hr>
<h3 id="一个线程运行时异常会发生什么">一个线程运行时异常会发生什么?</h3>
<p>Java中的<code>Throwable</code>主要分为<code>Exception</code>和<code>Error</code>。<code>Exception</code>分为运行时异常和非运行时异常。运行时异常可以不进行处理，代码也能通过编译，但运行时会报错。非运行时异常必须处理，否则代码无法通过编译。</p>
<hr>
<h3 id="线程数量过多会造成什么异常">线程数量过多会造成什么异常？</h3>
<ul>
<li>消耗更多的内存和CPU</li>
<li>频繁进行上下文切换</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://chimaeras.ltd/tag/3slSISDl_/" class="tag">
                    总结
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://chimaeras.ltd/post/java8-xin-te-xing/">
                  <h3 class="post-title">
                    Java8新特性
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>

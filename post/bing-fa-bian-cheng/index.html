<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>并发编程 | Joker&#39;s Blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://chimaeras.ltd/favicon.ico?v=1633763645519">
<link rel="stylesheet" href="https://chimaeras.ltd/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="三星
什么是进程？什么是线程？
线程是处理器任务调度和执行的基本单位，进程是操作系统资源分配的基本单位。
进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进程可以包含多个线程。

线程死锁是如何产生的，如..." />
    <meta name="keywords" content="总结" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://chimaeras.ltd">
        <img src="https://chimaeras.ltd/images/avatar.png?v=1633763645519" class="site-logo">
        <h1 class="site-title">Joker&#39;s Blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Chimaeras" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://chimaeras.ltd/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">并发编程</h2>
            <div class="post-date">2021-10-08</div>
            
            <div class="post-content" v-pre>
              <h2 id="三星">三星</h2>
<h3 id="什么是进程什么是线程">什么是进程？什么是线程？</h3>
<p>线程是处理器任务调度和执行的基本单位，进程是操作系统资源分配的基本单位。</p>
<p>进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进程可以包含多个线程。</p>
<hr>
<h3 id="线程死锁是如何产生的如何避免">线程死锁是如何产生的，如何避免</h3>
<p>死锁：由于两个或两个以上的线程相互竞争对方的资源，而同时不释放自己的资源，导致所有线程同时被阻塞。</p>
<p>死锁产生的条件：</p>
<ul>
<li>互斥条件：一个资源在同一时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程在请求被占资源时发生阻塞，并对已获得的资源保持不放。</li>
<li>循环等待条件：发生死锁时，所有的线程会形成一个死循环，一直阻塞。</li>
<li>不剥夺条件：线程已获得的资源在未使用完不能被其他线程剥夺，只能由自己使用完释放资源。</li>
</ul>
<p>避免死锁的方法主要是破坏死锁产生的条件。</p>
<ul>
<li>
<p>破坏互斥条件：这个条件无法进行破坏，锁的作用就是使他们互斥。</p>
</li>
<li>
<p>破坏请求与保持条件：一次性申请所有的资源。</p>
</li>
<li>
<p>破坏循环等待条件：按顺序来申请资源。</p>
</li>
<li>
<p>破坏不剥夺条件：线程在申请不到所需资源时，主动放弃所持有的资源。</p>
</li>
</ul>
<pre><code class="language-java">// 死锁示例
class DeadLockDemo {
    private static Object resource1 = new Object();
    private static Object resource2 = new Object();
 
    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000);   //线程休眠，保证线程2先获得资源2
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 1&quot;).start();
 
        new Thread(() -&gt; {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                try {
                    Thread.sleep(1000); //线程休眠，保证线程1先获得资源1
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                }
            }
        }, &quot;线程 2&quot;).start();
    }
}

// Thread[线程 1,5,main]get resource1
// Thread[线程 2,5,main]waiting get resource1
// Thread[线程 1,5,main]waiting get resource2
</code></pre>
<p>线程1获取到了资源1，线程2获取到了资源2，线程1继续获取资源2而产生阻塞，线程2继续获取资源1而产生阻塞。</p>
<p>解决办法为：按照顺序获取资源。</p>
<p>线程1和线程2都先获取资源1再获取资源2，无论哪个线程先获取到资源1，另一个线程都会因无法获取线程1产生阻塞，等到先获取到资源1的线程释放资源1，另一个线程获取资源1，这样两个线程可以轮流获取资源1和资源2。</p>
<pre><code class="language-java"> 	private static Object resource1 = new Object();
    private static Object resource2 = new Object();
 
    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000); 
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 1&quot;).start();
 
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 2&quot;).start();
    }
}
</code></pre>
<hr>
<h3 id="进程和线程的关系区别">进程和线程的关系？（区别）</h3>
<p>定义：线程是处理器任务调度和执行的基本单位；进程是操作系统资源分配的基本单位。</p>
<p>包含关系：一个进程可以包含多个线程。</p>
<p>从Java虚拟机的角度来理解：Java虚拟机的运行时数据区包含堆（共享）、方法区（共享）、虚拟机栈、本地方法栈、程序计数器。各个进程之间是相互独立的，每个进程会包含多个线程，每个进程所包含的多个线程并不是相互独立的，这个线程会共享进程的堆和方法区，但这些线程不会共享虚拟机栈、本地方法栈、程序计数器。即每个进程所包含的多个线程共享进程的堆和方法区，并且具备私有的虚拟机栈、本地方法栈、程序计数器。</p>
<p>区别：</p>
<ul>
<li>内存分配：进程之间的地址空间和资源是相互独立的，同一个进程之间的线程会共享线程的地址空间和资源（堆和方法区）。</li>
<li>资源开销：每个进程具备各自的数据空间，进程之间的切换会有较大的开销。属于同一进程的线程会共享堆和方法区，同时具备私有的虚拟机栈、本地方法栈、程序计数器，线程之间的切换资源开销较小。</li>
</ul>
<hr>
<h3 id="线程的生命周期和状态">线程的生命周期和状态</h3>
<figure data-type="image" tabindex="1"><img src="https://chimaeras.ltd/post-images/1633759214853.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>new</td>
<td>初始状态，<strong>注意此时还未调用<code>start()</code>方法</strong></td>
</tr>
<tr>
<td>runnable</td>
<td>运行状态，包含就绪和运行中两种状态</td>
</tr>
<tr>
<td>blocked</td>
<td>阻塞状态</td>
</tr>
<tr>
<td>waiting</td>
<td>等待状态</td>
</tr>
<tr>
<td>time_waiting</td>
<td>超时等待状态，和等待状态不同的是，它可以在制定的时间自行返回</td>
</tr>
<tr>
<td>terminated</td>
<td>终止状态，线程运行结束</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="创建线程一共有哪几种方法">创建线程一共有哪几种方法？</h3>
<ul>
<li>继承<code>Thread</code>类创建线程</li>
<li>实现<code>Runnable</code>接口创建线程</li>
<li>使用<code>Callable</code>和<code>Future</code>创建线程</li>
<li>使用线程池例如用<code>Executor</code>框架</li>
</ul>
<p><strong>继承Thread类创建线程</strong>，首先继承Thread类，重写<code>run()</code>方法，在<code>main()</code>函数中调用子类实实例的<code>start()</code>方法。</p>
<pre><code class="language-java">public class ThreadDemo extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行&quot;);
    }
}

public class TheadTest {
    public static void main(String[] args) {
        ThreadDemo threadDemo = new ThreadDemo();     
        threadDemo.start();
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行结束&quot;);
    }
}

// main main()方法执行结束
// Thread-0 run()方法正在执行
</code></pre>
<p>**实现Runnable接口创建线程：**首先创建实现<code>Runnable</code>接口的类<code>RunnableDemo</code>，重写<code>run()</code>方法；创建类<code>RunnableDemo</code>的实例对象<code>runnableDemo</code>，以<code>runnableDemo</code>作为参数创建<code>Thread</code>对象，调用<code>Thread</code>对象的<code>start()</code>方法。</p>
<pre><code class="language-java">public class RunnableDemo implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中&quot;);
    }
}

public class RunnableTest {
    public static void main(String[] args) {
        RunnableDemo  runnableDemo = new RunnableDemo ();
        Thread thread = new Thread(runnableDemo);
        thread.start();
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);
}
    
// main main()方法执行完成
// Thread-0 run()方法执行中
</code></pre>
<p><strong>使用Callable和Future创建线程：</strong></p>
<ol>
<li>创建Callable接口的实现类<code>CallableDemo</code>，重写<code>call()</code>方法。</li>
<li>以类<code>CallableDemo</code>的实例化对象作为参数创建<code>FutureTask</code>对象。</li>
<li>以<code>FutureTask</code>对象作为参数创建<code>Thread</code>对象。</li>
<li>调用<code>Thread</code>对象的<code>start()</code>方法。</li>
</ol>
<pre><code class="language-java">class CallableDemo implements Callable&lt;Integer&gt; {    
    @Override    
    public Integer call() {        
        System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中&quot;);        
        return 0;    
    }
} 
class CallableTest {    
    public static void main(String[] args) throws ExecutionException, InterruptedException {  
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new CallableDemo());        
        Thread thread = new Thread(futureTask);        
        thread.start();        
        System.out.println(&quot;返回结果 &quot; + futureTask.get());        
        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);    
    }
}

// Thread-0 call()方法执行中
// 返回结果 0 
// main main()方法执行完成

</code></pre>
<p><strong>使用线程池例如用Executor框架：</strong> <code>Executors</code>可提供四种线程池，分别为：</p>
<ul>
<li><code>newCachedThreadPool</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li><code>newFixedThreadPool</code> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li><code>newScheduledThreadPool</code> 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li><code>newSingleThreadExecutor</code> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li>
</ul>
<pre><code class="language-java">class ThreadDemo extends Thread {    
    @Override    
    public void run() {        
        System.out.println(Thread.currentThread().getName() + &quot;正在执行&quot;);    
    }
}

class TestFixedThreadPool {        
    public static void main(String[] args) {        
        //创建一个可重用固定线程数的线程池        
        ExecutorService pool = Executors.newFixedThreadPool(2);        
        //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口        
        Thread t1 = new ThreadDemo();        
        Thread t2 = new ThreadDemo();        
        Thread t3 = new ThreadDemo();        
        Thread t4 = new ThreadDemo();        
        Thread t5 = new ThreadDemo();        
        //将线程放入池中进行执行        
        pool.execute(t1);        
        pool.execute(t2);        
        pool.execute(t3);        
        pool.execute(t4);        
        pool.execute(t5);        
        //关闭线程池        
        pool.shutdown();        
    }        
}

// pool-1-thread-2正在执行
// pool-1-thread-1正在执行
// pool-1-thread-1正在执行
// pool-1-thread-2正在执行
// pool-1-thread-1正在执行
</code></pre>
<hr>
<h3 id="runnable-和-callable-有什么区别">runnable 和 callable 有什么区别？</h3>
<p>相同点：</p>
<ul>
<li>两者都是接口</li>
<li>两者都需要调用<code>Thread.start</code>启动线程</li>
</ul>
<p>不同点：</p>
<ul>
<li>callable的核心是<code>call()</code>方法，允许返回值，<code>runnable</code>的核心是<code>run()</code>方法，没有返回值</li>
<li><code>call()</code>方法可以抛出异常，但是<code>run()</code>方法不行</li>
<li><code>callable</code>和<code>runnable</code>都可以应用于<code>executors</code>，<code>thread</code>类只支持<code>runnable</code></li>
</ul>
<hr>
<h3 id="线程的run和start有什么区别">线程的run()和start()有什么区别？</h3>
<ul>
<li>线程是通过<code>Thread</code>对象所对应的方法<code>run()</code>来完成其操作的，而线程的启动是通过<code>start()</code>方法执行的。</li>
<li><code>run()</code>方法可以重复调用，<code>start()</code>方法只能调用一次</li>
</ul>
<hr>
<h3 id="为什么调用start方法时会执行run方法而不直接执行run方法">为什么调用start()方法时会执行run()方法，而不直接执行run()方法？</h3>
<p><code>start()</code>方法来启动线程，真正实现了多线程运行，这时无需等待<code>run()</code>方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 <code>start()</code>方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行<code>run()</code>方法，这里方法<code>run()</code>称为线程体，它包含了要执行的这个线程的内容，<code>run()</code>方法运行结束，此线程随即终止。</p>
<p><code>run()</code>方法只是类的一个普通方法而已，如果直接调用<code>run</code>方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待<code>run()</code>方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>调用<code>start()</code>方法可以开启一个线程，而<code>run()</code>方法只是thread类中的一个普通方法，直接调用<code>run()</code>方法还是在主线程中执行的。</p>
<hr>
<h3 id="线程同步以及线程调度相关的方法有哪些">线程同步以及线程调度相关的方法有哪些？</h3>
<p><code>wait()</code>：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p>
<p><code>sleep()</code>：使当前线程进入指定毫秒数的休眠，暂停执行，需要处理<code>InterruptedException</code>。</p>
<p><code>notify()</code>：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。</p>
<p><code>notifyAll()</code>：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。</p>
<p><code>join()</code>：与<code>sleep()</code>方法一样，是一个可中断的方法，在一个线程中调用另一个线程的<code>join()</code>方法，会使得当前的线程挂起，直到执行<code>join()</code>方法的线程结束。例如在B线程中调用A线程的<code>join()</code>方法，B线程进入阻塞状态，直到A线程结束或者到达指定的时间。</p>
<p><code>yield()</code>：提醒调度器愿意放弃当前的CPU资源，使得当前线程从<code>RUNNING</code>状态切换到<code>RUNABLE</code>状态。</p>
<hr>
<h3 id="线程的sleep方法和yield方法有什么不同">线程的sleep()方法和yield()方法有什么不同？</h3>
<p><code>sleep()</code>方法使得当前线程暂停指定的时间，没有消耗CPU时间片。</p>
<p><code>sleep()</code>使得线程进入到阻塞状态，<code>yield()</code>只是对CPU进行提示，如果CPU没有忽略这个提示，会使得线程上下文的切换，进入到就绪状态。</p>
<p><code>sleep()</code>一定会完成给定的休眠时间，<code>yield()</code>不一定能完成。</p>
<p><code>sleep()</code>需要抛出InterruptedException，而<code>yield()</code>方法无需抛出异常。</p>
<hr>
<h3 id="sleep方法和wait方法的区别">sleep()方法和wait()方法的区别？</h3>
<p>相同点：</p>
<ul>
<li><code>wait()</code>方法和<code>sleep()</code>方法都可以使得线程进入到阻塞状态。</li>
<li><code>wait()</code>和<code>sleep()</code>方法都是可中断方法，被中断后都会收到中断异常。</li>
</ul>
<p>不同点：</p>
<ul>
<li><code>wait()</code>是Object的方法，<code>sleep()</code>是Thread的方法。</li>
<li><code>wait()</code>必须在同步方法中进行，<code>sleep()</code>方法不需要。</li>
<li>线程在同步方法中执行<code>sleep()</code>方法，不会释放monitor的锁，而<code>wait()</code>方法会释放monitor的锁。</li>
<li><code>sleep()</code>方法在短暂的休眠之后会主动退出阻塞，而<code>wait()</code>方法在没有指定wait时间的情况下需要被其他线程中断才可以退出阻塞。</li>
</ul>
<hr>
<h3 id="wait方法一般在循环块中使用还是if块中使用">wait()方法一般在循环块中使用还是if块中使用？</h3>
<p>在JDK官方文档中明确要求了要在循环中使用，否则可能出现虚假唤醒的可能。官方文档中给出的代码示例如下：</p>
<pre><code class="language-java">synchronized(obj){    
    while(&lt;condition does not hold&gt;){         
        obj.wait();   
    }    //满足while中的条件后执行业务逻辑
}
</code></pre>
<p>如果讲<code>while</code>换成<code>if</code>：</p>
<pre><code class="language-java">synchronized(obj){    
	if(&lt;condition does not hold&gt;){         
		obj.wait();    
	}    
	//满足while中的条件后执行业务逻辑
}
</code></pre>
<p>当线程被唤醒后，可能<code>if()</code>中的条件已经不满足了，出现虚假唤醒。</p>
<hr>
<h3 id="线程通信的方法有哪些">线程通信的方法有哪些？</h3>
<ul>
<li>锁与同步</li>
<li><code>wait()</code>/<code>notify()</code>或<code>notifyAll()</code></li>
<li>信号量</li>
<li>管道</li>
</ul>
<hr>
<h3 id="什么是线程同步什么是线程互斥他们是如何实现的">什么是线程同步？什么是线程互斥？他们是如何实现的？</h3>
<ul>
<li>线程的互斥是指某一个资源只能被一个访问者访问，具有唯一性和排他性。但访问者对资源访问的顺序是乱序的。</li>
<li>线程的同步是指在互斥的基础上使得访问者对资源进行有序访问。</li>
</ul>
<p>线程同步的实现方法：</p>
<ul>
<li>同步方法</li>
<li>同步代码块</li>
<li><code>wait()</code>和<code>notify()</code></li>
<li>使用volatile实现线程同步</li>
<li>使用重入锁实现线程同步</li>
<li>使用局部变量实现线程同步</li>
<li>使用阻塞队列实现线程同步</li>
</ul>
<hr>
<h3 id="在java程序中如何保证线程的运行安全">在Java程序中如何保证线程的运行安全？</h3>
<p>线程安全问题 主要体现在原子性、可见性和有序性。</p>
<ul>
<li>原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性。线程切换带来的原子性问题。</li>
<li>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。缓存导致的可见性问题。</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行。编译优化带来的有序性问题。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>原子性问题：可用JDK <code>Atomic</code>开头的原子类、<code>synchronized</code>、<code>LOCK</code>来解决</li>
<li>可见性问题：可用<code>synchronized</code>、<code>volatile</code>、<code>LOCK</code>来解决</li>
<li>有序性问题：可用<code>Happens-Before</code> 规则来解决</li>
</ul>
<hr>
<h3 id="三个线程t1-t2-t3如何让他们按顺序执行">三个线程T1、T2、T3，如何让他们按顺序执行？</h3>
<p>这是一道面试中常考的并发编程的代码题，与它相似的问题有：</p>
<ul>
<li>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC.......</li>
<li>两个线程交替打印1-100的奇偶数</li>
<li>N个线程循环打印1-100</li>
<li>......</li>
</ul>
<p>其实这类问题本质上都是线程通信问题，思路基本上都是一个线程执行完毕，阻塞该线程，唤醒其他线程，按顺序执行下一个线程。下面先来看最简单的，如何按顺序执行三个线程。</p>
<ul>
<li>synchronized+wait/notify</li>
</ul>
<p>基本思路就是线程A、线程B、线程C三个线程同时启动，因为变量<code>num</code>的初始值为<code>0</code>，所以线程B或线程C拿到锁后，进入<code>while()</code>循环，然后执行<code>wait()</code>方法，线程线程阻塞，释放锁。只有线程A拿到锁后，不进入<code>while()</code>循环，执行<code>num++</code>，打印字符<code>A</code>，最后唤醒线程B和线程C。此时<code>num</code>值为<code>1</code>，只有线程B拿到锁后，不被阻塞，执行<code>num++</code>，打印字符<code>B</code>，最后唤醒线程A和线程C，后面以此类推。</p>
<pre><code class="language-java">class Wait_Notify_ACB {    
    private int num;    
    private static final Object LOCK = new Object();    
    private void printABC(String name, int targetNum) {            
        synchronized (LOCK) {                
            while (num % 3 != targetNum) {    
                //想想这里为什么不能用if代替while，想不起来可以看上一篇文章                    
                try {                        
                    LOCK.wait();                    
                } catch (InterruptedException e) {                        
                    e.printStackTrace();                    
                }                
            }                
            num++;                
            System.out.print(name);                
            LOCK.notifyAll();            
        }    
    }        
    
    public static void main(String[] args) {        
        Wait_Notify_ACB  wait_notify_acb = new Wait_Notify_ACB ();        
        new Thread(() -&gt; {            
            wait_notify_acb.printABC(&quot;A&quot;, 0);        
        }, &quot;A&quot;).start();        
        new Thread(() -&gt; {            
            wait_notify_acb.printABC(&quot;B&quot;, 1);        
        }, &quot;B&quot;).start();        
        new Thread(() -&gt; {            
            wait_notify_acb.printABC(&quot;C&quot;, 2);        
        }, &quot;C&quot;).start();    
    }
}
</code></pre>
<p>接下来看看第一个问题，三个线程T1、T2、T3轮流打印ABC，打印n次。其实只需要将上述代码加一个循环即可，这里假设n=10。</p>
<pre><code class="language-java">class Wait_Notify_ACB {    
    private int num;    
    private static final Object LOCK = new Object();    
    private void printABC(String name, int targetNum) {        
        for (int i = 0; i &lt; 10; i++) {            
            synchronized (LOCK) {                
                while (num % 3 != targetNum) { 
                    //想想这里为什么不能用if代替，想不起来可以看上一篇文章                    
                    try {                        
                        LOCK.wait();                    
                    } catch (InterruptedException e) {                        
                        e.printStackTrace();                    
                    }                
                }                
                num++;                
                System.out.print(name);                
                LOCK.notifyAll();            
            }        
        }    
    }        
    
    public static void main(String[] args) {        
        Wait_Notify_ACB  wait_notify_acb = new Wait_Notify_ACB ();        
        new Thread(() -&gt; {            
            wait_notify_acb.printABC(&quot;A&quot;, 0);        
        }, &quot;A&quot;).start();        
        new Thread(() -&gt; {            
            wait_notify_acb.printABC(&quot;B&quot;, 1);        
        }, &quot;B&quot;).start();        
        new Thread(() -&gt; {            
            wait_notify_acb.printABC(&quot;C&quot;, 2);        
        }, &quot;C&quot;).start();    
    }
}
</code></pre>
<p>下面看第二个问题，两个线程交替打印1-100的奇偶数，为了减少输入所占篇幅，这里将100 改成了10。基本思路上面类似，线程odd先拿到锁——打印数字——唤醒线程even——阻塞线程odd，以此循环。</p>
<pre><code class="language-java">class  Wait_Notify_Odd_Even{    
    private Object monitor = new Object();    
    private volatile int count;    
    Wait_Notify_Odd_Even(int initCount) {        
        this.count = initCount;    
    }    
    private void printOddEven() {        
        synchronized (monitor) {            
            while (count &lt; 10) {                
                try {                    
                    System.out.print( Thread.currentThread().getName() + &quot;：&quot;);                    
                    System.out.println(++count);                    
                    monitor.notifyAll();                    
                    monitor.wait();                
                } catch (InterruptedException e) {                    
                    e.printStackTrace();                
                }            
            }            
            //防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出            
            monitor.notifyAll();        
        }    
    }        
    public static void main(String[] args) throws InterruptedException {        
        Wait_Notify_Odd_Even waitNotifyOddEven = new Wait_Notify_Odd_Even(0);        
        new Thread(waitNotifyOddEven::printOddEven, &quot;odd&quot;).start();        
        Thread.sleep(10);        
        new Thread(waitNotifyOddEven::printOddEven, &quot;even&quot;).start();    
    }
}
</code></pre>
<p>面试官：大家都是用的synchronized+wait/notify，你能不能换个方法解决该问题？</p>
<p>我：好的，我还会用join方法</p>
<p><code>join()</code>方法：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。代码如下：</p>
<pre><code class="language-java">class Join_ABC {    
    public static void main(String[] args) throws InterruptedException {        
        for (int i = 0; i &lt; 10; i++) {            
            Thread t1 = new Thread(new printABC(null),&quot;A&quot;);            
            Thread t2 = new Thread(new printABC(t1),&quot;B&quot;);            
            Thread t3 = new Thread(new printABC(t2),&quot;C&quot;);            
            t0.start();            
            t1.start();            
            t2.start();            
            Thread.sleep(10); 
            //这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。        
        }    
    }    
    static class printABC implements Runnable{        
        private Thread beforeThread;        
        public printABC(Thread beforeThread) {            
            this.beforeThread = beforeThread;        
        }        
        @Override        
        public void run() {            
            if(beforeThread!=null) {                
                try {                    
                    beforeThread.join();                    
                    System.out.print(Thread.currentThread().getName());                
                }catch(Exception e){                    
                    e.printStackTrace();                
                }            
            }else {                
                System.out.print(Thread.currentThread().getName());            
            }        
        }    
    }
}
</code></pre>
<p>面试官：还会其他方法吗？</p>
<p>我：还会Lock。</p>
<p>该方法很容易理解，其实现代码和synchronized+wait/notify方法的很像。不管哪个线程拿到锁，只有符合条件的才能打印。代码如下：</p>
<pre><code class="language-java"> class Lock_ABC {    
     private int num;   
     // 当前状态值：保证三个线程之间交替打印    
     private Lock lock = new ReentrantLock();    
     private void printABC(String name, int targetNum) {        
         for (int i = 0; i &lt; 10; ) {            
             lock.lock();            
             if (num % 3 == targetNum) {                
                 num++;                
                 i++;                
                 System.out.print(name);            
             }            
             lock.unlock();        
         }    
     }    
     public static void main(String[] args) {        
         Lock_ABC lockABC = new Lock_ABC();        
         new Thread(() -&gt; {            
             lockABC.printABC(&quot;A&quot;, 0);        
         }, &quot;A&quot;).start();        
         new Thread(() -&gt; {            
             lockABC.printABC(&quot;B&quot;, 1);        
         }, &quot;B&quot;).start();        
         new Thread(() -&gt; {            
             lockABC.printABC(&quot;C&quot;, 2);        
         }, &quot;C&quot;).start();    
     }
 }
</code></pre>
<p>面试官：该方法存在什么问题，可以进一步优化吗</p>
<p>我：可以使用Lock+Condition实现对线程的精准唤醒，减少对其他线程无意义地唤醒，浪费资源。</p>
<ul>
<li>Lock+Condition</li>
</ul>
<p>该思路和synchronized+wait/notify方法的更像了，synchronized对应lock，await/signal方法对应wait/notify方法。下面的代码为了能精准地唤醒下一个线程，创建了多个Condition对象。</p>
<pre><code class="language-java">class LockConditionABC {    
    private int num;    
    private static Lock lock = new ReentrantLock();    
    private static Condition c1 = lock.newCondition();    
    private static Condition c2 = lock.newCondition();    
    private static Condition c3 = lock.newCondition();    
    private void printABC(String name, int targetNum, Condition currentThread, Condition nextThread) {        
        for (int i = 0; i &lt; 10; ) {            
            lock.lock();            
            try {                
                while (num % 3 != targetNum) {                    
                    currentThread.await();                
                }                
                num++;                
                i++;                
                System.out.print(name);                
                nextThread.signal();            
            } catch (Exception e) {                
                e.printStackTrace();            
            } finally {                
                lock.unlock();            
            }        
        }    
    }    
    public static void main(String[] args) {        
        LockConditionABC print = new LockConditionABC();        
        new Thread(() -&gt; {            
            print.printABC(&quot;A&quot;, 0, c1, c2);        
        }, &quot;A&quot;).start();        
        new Thread(() -&gt; {            
            print.printABC(&quot;B&quot;, 1, c2, c3);        
        }, &quot;B&quot;).start();        
        new Thread(() -&gt; {            
            print.printABC(&quot;C&quot;, 2, c3, c1);        
        }, &quot;C&quot;).start();    
    }
}
</code></pre>
<p>面试官：除了该方法，还有什么方法可以避免唤醒其他无意义的线程？</p>
<p>我：可以通过使用信号量来实现。</p>
<ul>
<li>Semaphore</li>
</ul>
<p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p>
<p>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。</p>
<p>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p>
<pre><code class="language-java">class SemaphoreABC {    
    private static Semaphore s1 = new Semaphore(1);  
    //先打印A，所以设s1中的计数器值为1    
    private static Semaphore s2 = new Semaphore(0);    
    private static Semaphore s3 = new Semaphore(0);        
    private void printABC(String name, Semaphore currentThread, Semaphore nextThread) {        
        for (int i = 0; i &lt; 10; i++) {            
            try {                
                currentThread.acquire();   
                //阻塞当前线程，即调用当前线程acquire()，计数器减1为0                
                System.out.print(name);                
                nextThread.release();    
                //唤醒下一个线程，即调用下一个线程线程release()，计数器加1            
            } catch (InterruptedException e) {                
                e.printStackTrace();            
            }        
        }    
    }    
    public static void main(String[] args) throws InterruptedException {        
        SemaphoreABC printer = new SemaphoreABC();        
        new Thread(() -&gt; {            
            printer.printABC(&quot;A&quot;, s1, s2);        
        }, &quot;A&quot;).start();        
        Thread.sleep(10);        
        new Thread(() -&gt; {            
            printer.printABC(&quot;B&quot;, s2, s3);        
        }, &quot;B&quot;).start();        
        Thread.sleep(10);        
        new Thread(() -&gt; {            
            printer.printABC(&quot;C&quot;, s3, s1);        
        }, &quot;C&quot;).start();    
    }
}
</code></pre>
<hr>
<h3 id="synchronized关键字">synchronized关键字</h3>
<h4 id="什么是synchronized关键字">什么是synchronized关键字？</h4>
<p>在多线程的环境下，多个线程同时访问共享资源会出现一些问题，而synchronized关键字则是用来保证线程同步的。</p>
<h4 id="java内存的可见性问题">Java内存的可见性问题</h4>
<p>java本地内存并不是真实存在的，只是Java内存模型的一个抽象概念，它包含了控制器、运算器、缓存等。同时Java内存模型规定，线程对共享变量的操作必须在自己的本地内存中进行，不能直接在主内存中操作共享变量。这种内存模型会出现什么问题呢？</p>
<ul>
<li>
<p>线程A获取到共享变量X的值，此时本地内存A中没有X的值，所以加载主内存中的X值并缓存到本地内存A中，线程A修改X的值为1，并将X的值刷新到主内存中，这时主内存及本地内存中的X的值都为1。</p>
</li>
<li>
<p>线程B需要获取共享变量X的值，此时本地内存B中没有X的值，加载主内存中的X值并缓存到本地内存B中，此时X的值为1。线程B修改X的值为2，并刷新到主内存中，此时主内存及本地内存B中的X值为2，本地内存A中的X值为1。</p>
</li>
<li>
<p>线程A再次获取共享变量X的值，此时本地内存中存在X的值，所以直接从本地内存中A获取到了X为1的值，但此时主内存中X的值为2，到此出现了所谓内存不可见的问题。</p>
</li>
</ul>
<p>该问题Java内存模型是通过synchronized关键字和volatile关键字就可以解决，那么synchronized关键字是如何解决的呢，其实进入synchronized块就是把在synchronized块内使用到的变量从线程的本地内存中擦除，这样在synchronized块中再次使用到该变量就不能从本地内存中获取了，需要从主内存中获取，解决了内存不可见问题。</p>
<h4 id="synchronized关键字三大特性是什么">synchronized关键字三大特性是什么？</h4>
<blockquote>
<p>面试时经常拿synchronized关键字和volatile关键字的特性进行对比，synchronized关键字可以保证并发编程的三大特性：原子性、可见性、有序性，而volatile关键字只能保证可见性和有序性，不能保证原子性，也称为是轻量级的synchronized。</p>
</blockquote>
<ul>
<li>原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</li>
<li>可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时，会对应执行 lock 、unlock原子操作，保证可见性。</li>
<li>有序性：程序的执行顺序会按照代码的先后顺序执行。</li>
</ul>
<h4 id="synchronized关键字可以实现什么类型的锁">synchronized关键字可以实现什么类型的锁？</h4>
<ul>
<li>
<p>悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。</p>
</li>
<li>
<p>非公平锁：synchronized关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。</p>
</li>
<li>
<p>可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。</p>
</li>
<li>
<p>独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。</p>
</li>
</ul>
<h4 id="synchronized关键字的使用方式">synchronized关键字的使用方式</h4>
<p>synchronized主要有三种使用方式：修饰普通同步方法、修饰静态同步方法、修饰同步方法块。</p>
<ul>
<li>修饰普通同步方法（实例方法）</li>
</ul>
<pre><code class="language-java">class syncTest implements Runnable {    
    private static int i = 0;   
    //共享资源    
    private synchronized void add() {        
        i++;    
    }    
    @Override    
    public void run() {        
        for (int j = 0; j &lt; 10000; j++) {            
            add();        
        }    
    }    
    public static void main(String[] args) throws Exception {        
        syncTest syncTest = new syncTest();        
        Thread t1 = new Thread(syncTest);        
        Thread t2 = new Thread(syncTest);        
        t1.start();        
        t2.start();        
        t1.join();        
        t2.join();        
        System.out.println(i);    
    }
}
</code></pre>
<p>这是一个非常经典的例子，多个线程操作<code>i++</code>会出现线程不安全问题，这段代码的结果很容易得到 20000</p>
<p>大家可以再看看这段代码，猜一猜它的运行结果</p>
<pre><code class="language-java">class syncTest implements Runnable {    
    private static int i = 0;   
    //共享资源    
    private synchronized void add() {        
        i++;    
    }    
    @Override    
    public void run() {        
        for (int j = 0; j &lt; 10000; j++) {            
            add();        
        }    
    }    
    public static void main(String[] args) throws Exception {
        syncTest syncTest = new syncTest();        
        Thread t1 = new Thread(new syncTest());        
        Thread t2 = new Thread(new syncTest());        
        t1.start();        
        t2.start();        
        t1.join();        
        t2.join();        
        System.out.println(i);    
    }
}

// 18634
</code></pre>
<p>第二个示例中的<code>add()</code>方法虽然也使用synchronized关键字修饰了，但是因为两次<code>new syncTest()</code>操作建立的是两个不同的对象，也就是说存在两个不同的对象锁，线程t1和t2使用的是不同的对象锁，所以不能保证线程安全。那这种情况应该如何解决呢？因为每次创建的实例对象都是不同的，而类对象却只有一个，如果synchronized关键字作用于类对象，即用synchronized修饰静态方法，问题则迎刃而解。</p>
<ul>
<li>
<p>修饰静态方法</p>
<p>只需要在<code>add()</code>方法前用static修饰即可，即当synchronized作用于静态方法，锁就是当前的class对象。</p>
<pre><code class="language-java">class syncTest implements Runnable {    
    private static int i = 0;   
    //共享资源    
    private static synchronized void add() {        
        i++;    
    }    
    @Override    
    public void run() {        
        for (int j = 0; j &lt; 10000; j++) {            
            add();        
        }    
    }    
    public static void main(String[] args) throws Exception {     
        syncTest syncTest = new syncTest();        
        Thread t1 = new Thread(new syncTest());        
        Thread t2 = new Thread(new syncTest());        
        t1.start();        
        t2.start();        
        t1.join();        
        t2.join();        
        System.out.println(i);    
    }
}
</code></pre>
</li>
<li>
<p>修饰同步代码代码块</p>
<p>如果某些情况下，整个方法体比较大，需要同步的代码只是一小部分，如果直接对整个方法体进行同步，会使得代码性能变差，这时只需要对一小部分代码进行同步即可。代码如下：</p>
<pre><code class="language-java">class syncTest implements Runnable {    
    static int i = 0;   
    //共享资源    
    @Override    
    public void run() {        
        //其他操作.......        
        synchronized (this){   
            //this表示当前对象实例，这里还可以使用syncTest.class，表示class对象锁            
            for (int j = 0; j &lt; 10000; j++) {                
                i++;            
            }        
        }    
    }    
    public static void main(String[] args) throws Exception {        
        syncTest syncTest = new syncTest();        
        Thread t1 = new Thread(syncTest);        
        Thread t2 = new Thread(syncTest);        
        t1.start();        
        t2.start();        
        t1.join();        
        t2.join();        
        System.out.println(i);    
    }
}

// 20000
</code></pre>
</li>
</ul>
<h4 id="synchronized关键字的底层原理">synchronized关键字的底层原理</h4>
<p>在jdk1.6之前，synchronized被称为重量锁，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁。下面先介绍jdk1.6之前的synchronized原理。</p>
<ul>
<li>对象头</li>
</ul>
<p>在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>填充对齐</strong>。因为synchronized用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由<strong>Mark Word</strong>、<strong>Class MetadataAddress</strong>和<strong>Array length</strong>组成，如果对象头非数组类型，对象头则由<strong>Mark Word</strong>和<strong>Class MetadataAddress</strong>组成。在32位虚拟机中，数组类型的Java对象头的组成如下表：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mark Word</td>
<td>存储对象的hashCode、分代年龄和锁标记位</td>
<td>32bit</td>
</tr>
<tr>
<td>Class MetadataAddress</td>
<td>存储到对象类型数据的指针</td>
<td>32bit</td>
</tr>
<tr>
<td>Array length</td>
<td>数组的长度</td>
<td>32bit</td>
</tr>
</tbody>
</table>
<p>这里我们需要重点掌握的是<strong>Mark Word</strong>。</p>
<ul>
<li>Mark Word</li>
</ul>
<p>在运行期间，Mark Word中存储的数据会随着锁标志位的变化而变化，在32位虚拟机中，不同状态下的组成如下：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>4bit</th>
<th>1bit是否持有偏向锁</th>
<th>2bit标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁</td>
<td>对象的hashcode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID、Epoch</td>
<td>对象分代年龄</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>同左</td>
<td>同左</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向监视器对象的指针</td>
<td>同左</td>
<td>同左</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>其中线程ID表示持有偏向锁线程的ID，Epoch表示偏向锁的时间戳，偏向锁和轻量级锁是在jdk1.6中引入的。</p>
<ul>
<li>重量级锁的底部实现原理：Monitor</li>
</ul>
<p>在jdk1.6之前，synchronized只能实现重量级锁，Java虚拟机是基于Monitor对象来实现重量级锁的。</p>
<ul>
<li>
<p>当多个线程同时访问同步代码块时，首先会进入到EntryList中，然后通过CAS的方式尝试将Monitor中的owner字段设置为当前线程，同时count加1，若发现之前的owner的值就是指向当前线程的，recursions也需要加1。如果CAS尝试获取锁失败，则进入到EntryList中。</p>
</li>
<li>
<p>当获取锁的线程调用<code>wait()</code>方法，则会将owner设置为null，同时count减1，recursions减1，当前线程加入到WaitSet中，等待被唤醒。</p>
</li>
<li>
<p>当前线程执行完同步代码块时，则会释放锁，count减1，recursions减1。当recursions的值为0时，说明线程已经释放了锁。</p>
</li>
</ul>
<p>之前提到过一个常见面试题，为什么<code>wait()</code>、<code>notify()</code>等方法要在同步方法或同步代码块中来执行呢，这里就能找到原因，是因为<code>wait()</code>、<code>notify()</code>方法需要借助ObjectMonitor对象内部方法来完成。</p>
<p>简答：</p>
<p>​	Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter 和 monitorexit 指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。</p>
<h4 id="jdk16为什么要对synchronized进行优化">Jdk1.6为什么要对synchronized进行优化？</h4>
<p>因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大。</p>
<h4 id="jdk16对synchronized做了哪些优化">jDK1.6对synchronized做了哪些优化？</h4>
<ul>
<li>锁的升级</li>
</ul>
<p>在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，无锁状态，偏向锁状态、轻量级锁状态和重量级锁状态。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级</p>
<hr>
<h3 id="volatile关键字">volatile关键字</h3>
<h4 id="volatile的作用是什么">volatile的作用是什么？</h4>
<p><code>volatile</code>是一个轻量级的<code>synchronized</code>，一般作用与<strong>变量</strong>，在多处理器开发的过程中保证了内存的可见性。相比于<code>synchronized</code>关键字，<code>volatile</code>关键字的执行成本更低，效率更高。</p>
<h4 id="volatile的特性有哪些">volatile的特性有哪些？</h4>
<p>可见性：<code>volatile</code>可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。</p>
<p>有序性：<code>volatile</code>会通过禁止指令重<a href="">排序</a>进而保证有序性。</p>
<p>原子性：对于单个的<code>volatile</code>修饰的变量的读写是可以保证原子性的，但对于<code>i++</code>这种复合操作并不能保证原子性。这句话的意思基本上就是说<code>volatile</code>不具备原子性了。</p>
<h4 id="为什么代码会重排序">为什么代码会重<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>？</h4>
<p>计算机在执行程序的过程中，编译器和处理器通常会对指令进行重<a href="">排序</a>，这样做的目的是为了提高性能。具体可以看下面这个例子。</p>
<pre><code class="language-java">int a = 1;
int b = 2;
int a1 = a;
int b1 = b;
int a2 = a + a;
int b2 = b + b;
......
</code></pre>
<p>像这段代码，不断地交替读取a和b，会导致寄存器频繁交替存储a和b，使得代码性能下降，可对其进入如下重<a href="">排序</a>。</p>
<pre><code class="language-java">int a = 1;
int b = 2;
int a1 = a;
int a2 = a + a;
int b1 = b;
int b2 = b + b;
......
</code></pre>
<p>按照这样地顺序执行代码便可以避免交替读取a和b，这就是重<a href="">排序</a>地意义。</p>
<p>指令重<a href="">排序</a>一般分为编译器优化重排、指令并行重拍和内存系统重排三种。</p>
<ul>
<li>编译器优化重排：编译器在不改变单线程程序语义的情况下，可以对语句的执行顺序进行重新<a href="">排序</a>。</li>
<li>指令并行重排：现代处理器多采用指令级并行技术来将多条指令重叠执行。对于不存在<strong>数据依赖</strong>的程序，处理器可以对机器指令的执行顺序进行重新排列。</li>
<li>内存系统重排：因为处理器使用缓存和读/写缓冲区，使得加载（load）和存储（store）看上去像是在乱序执行。</li>
</ul>
<p>注：简单解释下数据依赖性：如果两个操作访问了同一个变量，并且这两个操作有一个是写操作，这两个操作之间就会存在数据依赖性，例如：</p>
<pre><code>a = 1;b = a;
</code></pre>
<p>如果对这两个操作的执行顺序进行重<a href="">排序</a>的话，那么结果就会出现问题。</p>
<blockquote>
<p>其实，这三种指令重排说明了一个问题，就是指令重排在单线程下可以提高代码的性能，但在多线程下可以会出现一些问题。</p>
</blockquote>
<h4 id="重排序会引发什么问题">重<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>会引发什么问题？</h4>
<p>前面已经说过了，在单线程程序中，重<a href="">排序</a>并不会影响程序的运行结果，而在多线程场景下就不一定了。可以看下面这个经典的例子，该示例出自《Java并发编程的艺术》。</p>
<p><a href="#">复制代码</a></p>
<pre><code class="language-java">class ReorderExample{    
    int a = 0;    
    boolean flag = false;    
    public void writer(){        
        a = 1;              
        // 操作1        
        flag = true;        
        // 操作2    
    }    
    public void reader(){        
        if(flag){          
            // 操作3            
            int i = a + a; 
            // 操作4        
        }    
    }
}
</code></pre>
<p>假设线程1先执行<code>writer()</code>方法，随后线程2执行<code>reader()</code>方法，最后程序一定会得到正确的结果吗？</p>
<p>答案是不一定的，如果代码按照下图的执行顺序执行代码则会出现问题。</p>
<p>操作1和操作2进行了重<a href="">排序</a>，线程1先执行<code>flag=true</code>，然后线程2执行操作3和操作4，线程2执行操作4时不能正确读取到<code>a</code>的值，导致最终程序运行结果出问题。这也说明了在多线程代码中，重<a href="">排序</a>会破坏多线程程序的语义。</p>
<h4 id="as-if-serial规则和happens-before规则的区别">as-if-serial规则和happens-before规则的区别？</h4>
<p>区别：</p>
<ul>
<li>
<p>as-if-serial定义：无论编译器和处理器如何进行重<a href="">排序</a>，单线程程序的执行结果不会改变。</p>
</li>
<li>
<p>happens-before定义：一个操作happens-before另一个操作，表示第一个的操作结果对第二个操作可见，并且第一个操作的执行顺序也在第二个操作之前。但这并不意味着Java虚拟机必须按照这个顺序来执行程序。如果重<a href="">排序</a>的后的执行结果与按happens-before关系执行的结果一致，Java虚拟机也会允许重<a href="">排序</a>的发生。</p>
</li>
<li>
<p>happens-before关系保证了同步的多线程程序的执行结果不被改变，as-if-serial保证了单线程内程序的执行结果不被改变。</p>
</li>
</ul>
<p>相同点：happens-before和as-if-serial的作用都是在不改变程序执行结果的前提下，提高程序执行的并行度。</p>
<h4 id="voliatile的实现原理内存可见性-有序性">voliatile的实现原理？(内存可见性、有序性)</h4>
<blockquote>
<p>导致内存不可见的主要原因就是Java内存模型中的本地内存和主内存之间的值不一致所导致，例如上面所说线程A访问自己本地内存A的X值时，但此时主内存的X值已经被线程B所修改，所以线程A所访问到的值是一个脏数据。那如何解决这种问题呢？</p>
</blockquote>
<p><code>volatile</code>可以保证内存可见性的关键是<code>volatile</code>的读/写实现了缓存一致性，缓存一致性的主要内容为：</p>
<ul>
<li>每个处理器会通过嗅探总线上的数据来查看自己的数据是否过期，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。</li>
<li>当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。</li>
</ul>
<p>那缓存一致性是如何实现的呢？可以发现通过<code>volatile</code>修饰的变量，生成汇编指令时会比普通的变量多出一个<code>Lock</code>指令，这个<code>Lock</code>指令就是<code>volatile</code>关键字可以保证内存可见性的关键，它主要有两个作用：</p>
<ul>
<li>将当前处理器缓存的数据刷新到主内存。</li>
<li>刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效。</li>
</ul>
<blockquote>
<p>前面提到重<a href="">排序</a>可以提高代码的执行效率，但在多线程程序中可以导致程序的运行结果不正确，那<code>volatile</code>是如何解决这一问题的呢？</p>
</blockquote>
<p>为了实现<code>volatile</code>的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重<a href="">排序</a>。</p>
<p>内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p>
<h5 id="java虚拟机插入内存屏障的策略">Java虚拟机插入内存屏障的策略</h5>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证Load1数据的读取先于Load2及后续所有读取指令的执行</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>保证Store1数据刷新到主内存先于Store2及后续所有存储指令</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>保证Load1数据的读取先于Store2及后续的所有存储指令刷新到主内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>保证Store1数据刷新到主内存先于Load2及后续所有读取指令的执行</td>
</tr>
</tbody>
</table>
<p>注：StoreLoad Barriers同时具备其他三个屏障的作用，它会使得该屏障之前的所有内存访问指令完成之后，才会执行该屏障之后的内存访问命令。</p>
<p>Java内存模型对编译器指定的<code>volatile</code>重<a href="">排序</a>规则为：</p>
<ul>
<li>当第一个操作是<code>volatile</code>读时，无论第二个操作是什么都不能进行重<a href="">排序</a>。</li>
<li>当第二个操作是<code>volatile</code>写时，无论第一个操作是什么都不能进行重<a href="">排序</a>。</li>
<li>当第一个操作是<code>volatile</code>写，第二个操作为<code>volatile</code>读时，不能进行重<a href="">排序</a>。</li>
</ul>
<p>根据<code>volatile</code>重<a href="">排序</a>规则，Java内存模型采取的是保守的屏障插入策略，<code>volatile</code>写是在前面和后面分别插入内存屏障，<code>volatile</code>读是在后面插入两个内存屏障，具体如下：</p>
<p><code>volatile</code>读：在每个<code>volatile</code>读后面分别插入LoadLoad屏障及LoadStore屏障（根据<code>volatile</code>重<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>规则第一条）</p>
<ul>
<li>volatile读--&gt;LoadLoad屏障--&gt;LoadStore屏障--&gt;普通读--&gt;普通写</li>
</ul>
<p>LoadLoad屏障的作用：禁止上面的所有普通读操作和上面的<code>volatile</code>读操作进行重<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>。</p>
<p>LoadStore屏障的作用：禁止下面的普通写和上面的<code>volatile</code>读进行重<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>。</p>
<p><code>volatile</code>写：在每个<code>volatile</code>写前面插入一个StoreStore屏障（为满足<code>volatile</code>重<a href="">排序</a>规则第二条），在每个<code>volatile</code>写后面插入一个StoreLoad屏障（为满足<code>volatile</code>重<a href="">排序</a>规则第三条），如下图所示</p>
<ul>
<li>普通读--&gt;普通写--&gt;LoadLoad屏障--&gt;volatile写--&gt;LoadStore屏障</li>
</ul>
<p>StoreStore屏障的作用：禁止上面的普通写和下面的<code>volatile</code>写重<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a></p>
<p>StoreLoad屏障的作用：防止上面的<code>volatile</code>写与下面可能出现的<code>volatile</code>读/写重<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>。</p>
<h4 id="volatile能使一个非原子操作变成一个原子操作吗">volatile能使一个非原子操作变成一个原子操作吗？</h4>
<p><code>volatile</code>只能保证可见性和有序性，但可以保证64位的<code>long</code>型和<code>double</code>型变量的原子性。</p>
<p>对于32位的虚拟机来说，每次原子读写都是32位的，会将<code>long</code>和<code>double</code>型变量拆分成两个32位的操作来执行，这样<code>long</code>和<code>double</code>型变量的读写就不能保证原子性了，而通过<code>volatile</code>修饰的long和double型变量则可以保证其原子性。</p>
<h4 id="volatile-synchronized的区别">volatile、synchronized的区别？</h4>
<ul>
<li>
<p><code>volatile</code>主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。<code>synchronized</code>主要是解决多个线程访问资源的同步性。</p>
</li>
<li>
<p><code>volatile</code>作用于变量，<code>synchronized</code>作用于代码块或者方法。</p>
</li>
<li>
<p><code>volatile</code>仅可以保证数据的可见性，不能保证数据的原子性。<code>synchronized</code>可以保证数据的可见性和原子性。</p>
</li>
<li>
<p><code>volatile</code>不会造成线程的阻塞，<code>synchronized</code>会造成线程的阻塞。</p>
</li>
</ul>
<hr>
<h3 id="concurrenthashmap">ConcurrentHashMap</h3>
<h4 id="什么是concurrenthashmap相比于hashmap和hashtable有什么优势">什么是ConcurrentHashMap？相比于HashMap和HashTable有什么优势？</h4>
<p><code>CocurrentHashMap</code>可以看作<strong>线程安全且高效</strong>的<code>HashMap</code>，相比于<code>HashMap</code>具有线程安全的优势，相比于<code>HashTable</code>具有效率高的优势。</p>
<h4 id="java中concurrenthashmap是如何实现的">java中ConcurrentHashMap是如何实现的？</h4>
<blockquote>
<p>这里经常会将jdk1.7中的<code>ConcurrentHashMap</code>和jdk1.8中的<code>ConcurrentHashMap</code>的实现方式进行对比。</p>
</blockquote>
<ul>
<li>JDK1.7</li>
</ul>
<p>在JDK1.7版本中，<code>ConcurrentHashMap</code>的数据结构是由一个<code>Segment</code>数组和多个<code>HashEntry</code>数组组成，<code>Segment</code>存储的是<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>数组的形式，如图所示。</p>
<figure data-type="image" tabindex="2"><img src="https://chimaeras.ltd/post-images/1633759095334.png" alt="" loading="lazy"></figure>
<p>从上图可以看出，<code>ConcurrentHashMap</code>定位一个元素的过程需要两次Hash的过程，第一次Hash的目的是定位到Segment，第二次Hash的目的是定位到<a href="">链表</a>的头部。两次Hash所使用的时间比一次Hash的时间要长，但这样做可以在写操作时，只对元素所在的segment枷锁，不会影响到其他segment，这样可以大大提高并发能力。</p>
<ul>
<li>JDK1.8</li>
</ul>
<p>JDK1.8不在采用segment的结构，而是使用Node数组+<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>/<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>的数据结构来实现的（和<code>HashMap</code>一样，<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>节点个数大于8，<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>会转换为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>）</p>
<figure data-type="image" tabindex="3"><img src="https://chimaeras.ltd/post-images/1633759143782.png" alt="" loading="lazy"></figure>
<p>从上图可以看出，对于<code>ConcurrentHashMap</code>的实现，JDK1.8的实现方式可以降低锁的粒度，因为JDLK1.7所实现的<code>ConcurrentHashMap</code>的锁的粒度是基于Segment，而一个Segment包含多个HashEntry。</p>
<h4 id="concurrenthashmap结构中变量使用volatile和final修饰有什么作用">ConcurrentHashMap结构中变量使用volatile和final修饰有什么作用？</h4>
<p><code>final</code>修饰变量可以保证变量不需要同步就可以被访问和共享，<code>volatile</code>可以保证内存的可见性，配合CAS操作可以在不加锁的前提支持并发。</p>
<h4 id="concurrenthashmap有什么缺点">ConcurrentHashMap有什么缺点？</h4>
<p>因为<code>ConcurrentHashMap</code>在更新数据时只会锁住部分数据，并不会将整个表锁住，读取的时候也并不能保证读取到最近的更新，只能保证读取到已经顺利插入的数据。</p>
<h4 id="concurrenthashmap默认初始容量是多少每次扩容为原来的几倍">ConcurrentHashMap默认初始容量是多少？每次扩容为原来的几倍？</h4>
<p>默认的初始容量为16，每次扩容为之前的两倍。</p>
<h4 id="concurrenthashmap-的keyvalue是否可以为null为什么hashmap中的key-value是否可以为null">ConCurrentHashMap 的key，value是否可以为null？为什么？HashMap中的key、value是否可以为null？</h4>
<p><code>ConCurrentHashMap</code>中的<code>key</code>和<code>value</code>为<code>null</code>会出现空指针异常，而<code>HashMap</code>中的<code>key</code>和<code>value</code>值是可以为<code>null</code>的。</p>
<p>原因如下：<code>ConCurrentHashMap</code>是在多线程场景下使用的，如果<code>ConcurrentHashMap.get(key)</code>的值为<code>null</code>，那么无法判断到底是<code>key</code>对应的<code>value</code>的值为<code>null</code>还是不存在对应的<code>key</code>值。而在单线程场景下的<code>HashMap</code>中，可以使用<code>containsKey(key)</code>来判断到底是不存在这个<code>key</code>还是<code>key</code>对应的<code>value</code>的值为<code>null</code>。在多线程的情况下使用<code>containsKey(key)</code>来做这个判断是存在问题的，因为在<code>containsKey(key)</code>和<code>ConcurrentHashMap.get(key)</code>两次调用的过程中，<code>key</code>的值已经发生了改变。</p>
<h4 id="concurrenthashmap在jdk18中什么情况下链表会转化为红黑树">ConCurrentHashmap在JDK1.8中，什么情况下<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>会转化为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>？</h4>
<p>当<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>长度大于8，Node数组数大于64时。</p>
<h4 id="concurrenthashmap在jdk17和jdk18版本中的区别">ConcurrentHashMap在JDK1.7和JDK1.8版本中的区别？</h4>
<ul>
<li>
<p>实现结构上的不同，JDK1.7是基于Segment实现的，JDK1.8是基于Node数组+<a href="">链表</a>/<a href="">红黑树</a>实现的。</p>
</li>
<li>
<p>保证线程安全方面：JDK1.7采用了分段锁的机制，当一个线程占用锁时，会锁住一个Segment对象，不会影响其他Segment对象。JDK1.8则是采用了CAS和<code>synchronize</code>的方式来保证线程安全。</p>
</li>
<li>
<p>在存取数据方面：</p>
<p><strong>JDK1.7中的<code>put()</code>方法：</strong></p>
</li>
</ul>
<ol>
<li>
<p>先计算出<code>key</code>的<code>hash</code>值，利用<code>hash</code>值对segment数组取余找到对应的segment对象。</p>
</li>
<li>
<p>尝试获取锁，失败则自旋直至成功，获取到锁，通过计算的<code>hash</code>值对hashentry数组进行取余，找到对应的entry对象。</p>
</li>
<li>
<p>遍历<a href="">链表</a>，查找对应的<code>key</code>值，如果找到则将旧的value直接覆盖，如果没有找到，则添加到<a href="">链表</a>中。（JDK1.7是插入到<a href="">链表</a>头部，JDK1.8是插入到<a href="">链表</a>尾部，这里可以思考一下为什么这样）</p>
<p><strong>JDK1.8中的<code>put()</code>方法:</strong></p>
</li>
<li>
<p>计算<code>key</code>值的<code>hash</code>值，找到对应的<code>Node</code>，如果当前位置为空则可以直接写入数据。</p>
</li>
<li>
<p>利用CAS尝试写入，如果失败则自旋直至成功，如果都不满足，则利用<code>synchronized</code>锁写入数据。</p>
</li>
</ol>
<h4 id="concurrenthashmap迭代器是强一致性还是弱一致性">ConcurrentHashMap迭代器是强一致性还是弱一致性？</h4>
<p>与HashMap不同的是，<code>ConcurrentHashMap</code>迭代器是弱一致性。</p>
<p>这里解释一下弱一致性是什么意思，当<code>ConcurrentHashMap</code>的迭代器创建后，会遍历<a href="">哈希表</a>中的元素，在遍历的过程中，<a href="">哈希表</a>中的元素可能发生变化，如果这部分变化发生在已经遍历过的地方，迭代器则不会反映出来，如果这部分变化发生在未遍历过的地方，迭代器则会反映出来。换种说法就是<code>put()</code>方法将一个元素加入到底层数据结构后，<code>get()</code>可能在某段时间内还看不到这个元素。</p>
<p>这样的设计主要是为<code>ConcurrenthashMap</code>的性能考虑，如果想做到强一致性，就要到处加锁，性能会下降很多。所以<code>ConcurrentHashMap</code>是支持在迭代过程中，向map中添加元素的，而<code>HashMap</code>这样操作则会抛出异常。</p>
<hr>
<h3 id="threadlocal">ThreadLocal</h3>
<h4 id="什么是threadlocal有哪些应用场景">什么是ThreadLocal？有哪些应用场景？</h4>
<p><code>ThreadLocal</code>是 JDK java.lang 包下的一个类，<code>ThreadLocal</code>为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，并且不会和其他线程的局部变量冲突，实现了线程间的数据隔离。</p>
<p><code>ThreadLocal</code>的应用场景主要有以下几个方面：</p>
<ul>
<li>保存线程上下文信息，在需要的地方可以获取</li>
<li>线程间数据隔离</li>
<li>数据库连接</li>
</ul>
<h4 id="threadlocal原理和内存泄露">ThreadLocal原理和内存泄露？</h4>
<figure data-type="image" tabindex="4"><img src="https://chimaeras.ltd/post-images/1633759069034.png" alt="" loading="lazy"></figure>
<p>从上图可以看出每个线程都有一个<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>中保存着所有的<code>ThreadLocal</code>，而<code>ThreadLocal</code>本身只是一个引用本身并不保存值，值都是保存在<code>ThreadLocalMap</code>中的，其中<code>ThreadLocal</code>为<code>ThreadLocalMap</code>中的<code>key</code>。其中图中的虚线表示弱引用。</p>
<p>这里简单说下Java中的引用类型，Java的引用类型主要分为强引用、软引用、弱引用和虚引用。</p>
<ul>
<li>
<p>强引用：发生 gc 的时候不会被回收。</p>
</li>
<li>
<p>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p>
</li>
<li>
<p>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</p>
</li>
<li>
<p>虚引用：无法通过虚引用获得对象，虚引用的用途是在 gc 时返回一个通知。</p>
</li>
</ul>
<h4 id="为什么threadlocal会发生内存泄漏呢"><strong>为什么ThreadLocal会发生内存泄漏呢？</strong></h4>
<p>因为<code>ThreadLocal</code>中的<code>key</code>是弱引用，而<code>value</code>是强引用。当<code>ThreadLocal</code>没有被强引用时，在进行垃圾回收时，<code>key</code>会被清理掉，而<code>value</code>不会被清理掉，这时如果不做任何处理，<code>value</code>将永远不会被回收，产生内存泄漏。</p>
<h4 id="如何解决threadlocal的内存泄漏"><strong>如何解决ThreadLocal的内存泄漏？</strong></h4>
<p>其实在<code>ThreadLocal</code>在设计的时候已经考虑到了这种情况，在调用<code>set()</code>、<code>get()</code>、<code>remove()</code>等方法时就会清理掉<code>key</code>为<code>null</code>的记录，所以在使用完<code>ThreadLocal</code>后最好手动调用<code>remove()</code>方法。</p>
<h4 id="为什么要将key设计成threadlocal的弱引用"><strong>为什么要将key设计成ThreadLocal的弱引用？</strong></h4>
<p>如果<code>ThreadLocal</code>的<code>key</code>是强引用，同样会发生内存泄漏的。如果<code>ThreadLocal</code>的<code>key</code>是强引用，引用的<code>ThreadLocal</code> 的对象被回收了，但是<code>ThreadLocalMap</code> 还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，发生内存泄漏。</p>
<p>如果是弱引用的话，引用的<code>ThreadLocal</code>的对象被回收了，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>也会在<code>ThreadLocalMap</code>调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 的时候会被清除。</p>
<p>所以两种方案比较下来，还是<code>ThreadLoacl</code>的<code>key</code>为弱引用好一些。</p>
<hr>
<h3 id="线程池">线程池</h3>
<h4 id="什么是线程池为什么使用线程池">什么是线程池？为什么使用线程池</h4>
<p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交给线程池来管理。</p>
<p><strong>为什么使用线程池？</strong></p>
<ul>
<li><strong>降低资源消耗</strong>，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>，当任务到达时，任务可以不需要等到线程创建就立即执行。</li>
<li><strong>提高线程的可管理性</strong>，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配。</li>
</ul>
<h4 id="创建线程池的几种方法">创建线程池的几种方法</h4>
<p>线程池的常用创建方式主要有两种，通过<strong>Executors工厂方法创建</strong>和**通过new <code>ThreadPoolExecutor</code>**方法创建。</p>
<ul>
<li>
<p>Executors工厂方法创建，在工具类 Executors 提供了一些静态的工厂方法</p>
<ol>
<li><code>newSingleThreadExecutor</code>：创建一个单线程的线程池。</li>
<li><code>newFixedThreadPool</code>：创建固定大小的线程池。</li>
<li><code>newCachedThreadPool</code>：创建一个可缓存的线程池。</li>
<li><code>newScheduledThreadPool</code>：创建一个大小无限的线程池。</li>
</ol>
</li>
<li>
<p><code>new ThreadPoolExecutor</code> 方法创建：</p>
<pre><code class="language-java">new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue，ThreadFactory threadFactory,RejectedExecutionHandler handler)    
</code></pre>
</li>
</ul>
<h4 id="threadpoolexecutor构造函数的重要参数分析">ThreadPoolExecutor构造函数的重要参数分析</h4>
<p>三个比较重要的参数：</p>
<ul>
<li><strong><code>corePoolSize</code></strong> ：核心线程数，定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code></strong> ：线程中允许存在的最大工作线程数量</li>
<li><strong><code>workQueue</code></strong>：存放任务的阻塞队列。新来的任务会先判断当前运行的线程数是否到达核心线程数，如果到达的话，任务就会先放到阻塞队列。</li>
</ul>
<p>其他参数：</p>
<ul>
<li><code>keepAliveTime</code>：当线程池中的数量大于核心线程数时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到时间超过<code>keepAliveTime</code>时才会被销毁。</li>
<li><strong><code>unit</code></strong> ：<code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong>：为线程池提供创建新线程的线程工厂。</li>
<li><strong><code>handler</code></strong> ：线程池任务队列超过<code>maxinumPoolSize</code> 之后的拒绝策略</li>
</ul>
<h4 id="threadpoolexecutor的饱和策略拒绝策略">ThreadPoolExecutor的饱和策略（拒绝策略）</h4>
<p>当同时运行的线程数量达到最大线程数量并且阻塞队列也已经放满了任务时，<code>ThreadPoolExecutor</code>会指定一些饱和策略。主要有以下四种类型：</p>
<ul>
<li><code>AbortPolicy</code>策略：该策略会直接抛出异常拒绝新任务</li>
<li><code>CallerRunsPolicy</code>策略：当线程池无法处理当前任务时，会将该任务交由提交任务的线程来执行。</li>
<li><code>DiscardPolicy</code>策略：直接丢弃新任务。</li>
<li><code>DiscardOleddestPolicy</code>策略：丢弃最早的未处理的任务请求。</li>
</ul>
<p>&lt;线程池执行流程&gt;</p>
<h4 id="execute方法和submit方法的区别">execute()方法和submit()方法的区别</h4>
<p><code>execute()</code>和<code>submit()</code>的区别主要有两点：</p>
<ul>
<li><code>execute()</code>方法只能执行<code>Runnable</code> 类型的任务。<code>submit()</code>方法可以执行<code>Runnable</code>和 <code>Callable</code>类型的任务。</li>
<li><code>submit()</code>方法可以返回持有计算结果的<code>Future</code>对象，同时还可以抛出异常，而<code>execute()</code>方法不可以。</li>
</ul>
<p>换句话说就是，<code>execute()</code>方法用于提交不需要返回值的任务，<code>submit()</code>方法用于需要提交返回值的任务。</p>
<hr>
<h3 id="cas">CAS</h3>
<h4 id="什么是cas">什么是CAS?</h4>
<p>CAS即CompareAndSwap，翻译成中文即比较并替换。Java中可以通过CAS操作来保证原子性，原子性就是不可被中断的一些列操作或者一个操作，简单来说就是一系列操作，要么全部完成，要么失败，不能被中断。</p>
<p>CAS主要包含三个参数（V，A，B）, <strong>V 表示要更新的变量（内存位置）、A 表示预期原值（旧值）、B表示新值</strong>。<a href="">算法</a>流程是首先比较A和B的值，如果相等，将B值赋值给V，如果不相等说明有其他线程对该变量做了更新。即：我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可</p>
<p>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。</p>
<h4 id="cas存在的问题">CAS存在的问题</h4>
<ul>
<li>ABA问题</li>
</ul>
<p>在CAS的<a href="">算法</a>流程中，首先要先比较V的值和A的值，如果相等则进行更新。ABA问题是指，A表示的这个旧值本来是a，然后变成了b，后来又变成了a，但这时有线程来更新，发现A表示的值是a，则直接进行更新了，这样肯定是不对的，但又该怎么解决呢？</p>
<p>ABA的问题的解决方式：ABA的解决方法也很简单，就是利用<strong>版本号</strong>。给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使E的值从A—&gt;B—&gt;A，版本号也发生了变化，这样就解决了CAS出现的ABA问题。基于CAS的乐观锁也是这个实现原理。</p>
<ul>
<li>循环时间过长导致开销太大</li>
</ul>
<p>CAS自旋时间过长会给CPU带来非常大的开销</p>
<ul>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<p>在操作一个共享变量时，可以通过CAS的方式保证操作的原子性，但如果对多个共享变量进行操作时，CAS则无法保证操作的原子性，这时候就需要用锁了。在看《Java并发编程的艺术》时，里面提到了一个办法可以参考一下，就是将多个共享变量合并成一个共享变量来操作。比如，有两个共享变量<code>i=2,j=a</code>，合并成<code>ij=2a</code>，然后用CAS来操作<code>ij</code></p>
<h4 id="cas的优点">CAS的优点</h4>
<p>在并发量不是很大时提高效率。</p>
<h4 id="atomic-原子类">Atomic 原子类</h4>
<blockquote>
<p>原子操作类是CAS在Java中的应用，从JDK1.5开始提供了<code>java.util.concurrent.atomic</code>包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。Atomic包里的类基本都是使用<code>Unsafe</code>实现的包装类。</p>
</blockquote>
<p>JUC包中的4种原子类</p>
<ul>
<li>
<p>基本类型</p>
<p>：使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
</li>
<li>
<p>数组类型</p>
<p>：使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
</li>
<li>
<p>引用类型</p>
<p>：</p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类，存在ABA问题</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型</li>
</ul>
</li>
<li>
<p>原子更新字段类</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicReferenceFieldUpdater：引用类型更新器原子类</li>
</ul>
</li>
</ul>
<hr>
<h2 id="两星">两星</h2>
<h3 id="多线程的优缺点为什么使用多线程-多线程会引发什么问题">多线程的优缺点（为什么使用多线程、多线程会引发什么问题）</h3>
<p>优点：当一个线程进入等待状态或者阻塞时，CPU可以先去执行其他线程，提高CPU的利用率。</p>
<p>缺点：</p>
<ul>
<li>上下文切换：频繁的上下文切换会影响多线程的执行速度。</li>
<li>死锁</li>
<li>资源限制：在进行并发编程时，程序的执行速度受限于计算机的硬件或软件资源。在并发编程中，程序执行变快的原因是将程序中串行执行的部分变成并发执行，如果因为资源限制，并发执行的部分仍在串行执行，程序执行将会变得更慢，因为程序并发需要上下文切换和资源调度。</li>
</ul>
<hr>
<h3 id="为什么wait-notify-notifyall被定义在object类中而不是在thread类中">为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？</h3>
<p>因为这些方法在操作同步线程时，都必须要标识他们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的<code>notify()</code>或<code>notifyAll()</code>唤醒，不可以对不同锁中的线程进行唤醒，也就是说等待和唤醒必须是同一锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在<code>Object</code>类中。</p>
<p>如果把<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>定义在Thread类中，则会出现一些难以解决的问题，例如如何让一个线程可以持有多把锁？如何确定线程等待的是哪把锁？既然是当前线程去等待某个对象的锁，则应通过操作对象来实现而不是操作线程，而Object类是所有对象的父类，所以将这三种方法定义在Object类中最合适。</p>
<hr>
<h3 id="为什么waitnotify和notifyall必须在同步方法或者同步块中被调用">为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3>
<p>因为<code>wait()</code>暂停的是持有锁的对象，<code>notify()</code>或<code>notifyAll()</code>唤醒的是等待锁的对象。所以<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>都需要线程持有锁的对象，进而需要在同步方法或者同步块中被调用。</p>
<hr>
<h3 id="如何停止一个正在运行的线程">如何停止一个正在运行的线程？</h3>
<ul>
<li>中断：<code>Interrupt</code>方法中断线程</li>
<li>使用<code>volatile boolean</code>标志位停止线程：在线程中设置一个<code>boolean</code>标志位，同时用<code>volatile</code>修饰保证可见性，在线程里不断地读取这个值，其他地方可以修改这个<code>boolean</code>值。</li>
<li>使用<code>stop()</code>方法停止线程，但该方法已经被废弃。因为这样线程不能在停止前保存数据，会出现数据完整性问题。</li>
</ul>
<hr>
<h3 id="如何唤醒一个阻塞的线程">如何唤醒一个阻塞的线程？</h3>
<p>如果线程是由于<code>wait()</code>、<code>sleep()</code>、<code>join()</code>、<code>yield()</code>等方法进入阻塞状态的，是可以进行唤醒的。如果线程是IO阻塞是无法进行唤醒的，因为IO是操作系统层面的，Java代码无法直接接触操作系统。</p>
<ul>
<li><code>wait()</code>：可用<code>notify()</code>或<code>notifyAll()</code>方法唤醒。</li>
<li><code>sleep()</code>：调用该方法使得线程在指定时间内进入阻塞状态，等到指定时间过去，线程再次获取到CPU时间片进而被唤醒。</li>
<li><code>join()</code>：当前线程A调用另一个线程B的<code>join()</code>方法，当前线程转A入阻塞状态，直到线程B运行结束，线程A才由阻塞状态转为可执行状态。</li>
<li><code>yield()</code>：使得当前线程放弃CPU时间片，但随时可能再次得到CPU时间片进而激活。</li>
</ul>
<hr>
<h3 id="java如何实现两个线程之间的通信和协作">Java如何实现两个线程之间的通信和协作？</h3>
<p>syncrhoized<code>加锁的线程的</code>Object<code>类的</code>wait()<code>/</code>notify()<code>/</code>notifyAll()<br>
ReentrantLock<code>类加锁的线程的</code>Condition<code>类的</code>await()<code>/</code>signal()<code>/</code>signalAll()</p>
<p>通过管道进行线程间通信：1）字节流；2）字符流 ，就是一个线程发送数据到输出管道，另一个线程从输入管道读数据。</p>
<hr>
<h3 id="同步方法和同步方法块哪个效果更好">同步方法和同步方法块哪个效果更好？</h3>
<p>同步块更好些，因为它锁定的范围更灵活些，只在需要锁住的代码块锁住相应的对象，而同步方法会锁住整个对象。</p>
<hr>
<h3 id="aqs">AQS</h3>
<h4 id="什么是aqs">什么是AQS？</h4>
<p>AQS的全称是<code>AbstractQueuedSynchronizer</code>，是一个用来构建锁和同步器的框架，像ReentrantLock，Semaphore，FutureTask都是基于AQS实现的。</p>
<h4 id="aqs的原理">AQS的原理</h4>
<p>简单来说，AQS就是维护了一个共享资源，然后使用队列来保证线程排队获取资源的一个过程。</p>
<p>AQS的工作流程：当被请求的共享资源空闲，则将请求资源的线程设为有效的工作线程，同时锁定共享资源。如果被请求的资源已经被占用了，AQS就用过队列实现了一套线程阻塞等待以及唤醒时锁分配的机制。</p>
<p>这个队列是通过CLH队列实现的，从上图可以看出，该队列是一个双向队列，有Node结点组成，每个Node结点维护一个prev引用和next引用，这两个引用分别指向自己结点的前驱结点和后继结点，同时AQS还维护两个指针Head和Tail，分别指向队列的头部和尾部。</p>
<h4 id="aqs的资源共享方式有哪些">AQS的资源共享方式有哪些？</h4>
<ul>
<li>Exclusive：独占，只有一个线程可以执行，例如ReentrantLock</li>
<li>Share：共享，多个现场可以同时执行，如Semaphore、CountDownLatch</li>
</ul>
<h3 id="如何使用aqs定义同步器">如何使用AQS定义同步器</h3>
<p>AQS的底层使用了模板方法模式，自定义同步器只需要两步：第一，继承<code>AbstractQueuedSynchronizer</code>，第二，重写以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式，尝试获取资源。</li>
<li>tryRelease(int)：独占方式，尝试释放资源。</li>
<li>tryAcquireShared(int)：共享方式，尝试获取资源。负数表示失败，0表示成功，但无剩余可用资源，正数表示成功并且有剩余资源</li>
<li>tryReleaseShared(int)：共享方式，尝试释放资源</li>
</ul>
<p>下面举例说明，以独占式的<code>ReentrantLock</code>为例，<code>state</code>初始状态为0，表示未锁定状态。A线程进行<code>lock()</code>时，会调用<code>tryAcquire()</code>独占该锁并将<code>state+1</code>。此后，其他线程再调用<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以共享使得<code>CountDownLatch</code>以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后<code>countDown()</code>一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会<code>unpark()</code>主调用线程，然后主调用线程就会从<code>await()</code>函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<hr>
<h2 id="一星">一星</h2>
<h3 id="并行和并发的区别">并行和并发的区别？</h3>
<p>并行：单位时间多个处理器同时处理多个任务。</p>
<p>并发：一个处理器处理多个任务，按时间片轮流处理多个任务。</p>
<hr>
<h3 id="线程的上下文切换">线程的上下文切换</h3>
<p>即便是单核的处理器也会支持多线程，处理器会给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。</p>
<p>CPU会通过时间片分配<a href="">算法</a>来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，从任务保存到在加载的过程就是一次上下文切换。</p>
<hr>
<h3 id="java中守护线程和用户线程的区别">Java中守护线程和用户线程的区别？</h3>
<p>任何线程都可以设置为守护线程和用户线程，通过方法<code>Thread.setDaemon(bool on)</code> 设置，<code>true</code>则是将该线程设置为守护线程，<code>false</code>则是将该线程设置为用户线程。同时，<code>Thread.setDaemon()</code>必须在<code>Thread.start()</code>之前调用，否则运行时会抛出异常。</p>
<p>用户线程：平时使用到的线程均为用户线程。</p>
<p>守护线程：用来服务用户线程的线程，例如垃圾回收线程。</p>
<p>区别：主要在于Java虚拟机是否存活。</p>
<ul>
<li>
<p>用户线程：当任何一个用户线程未结束，Java虚拟机是不会结束的。</p>
</li>
<li>
<p>守护线程：如果只剩守护线程未结束，Java虚拟机结束。</p>
</li>
</ul>
<hr>
<h3 id="java中的死锁-活锁-饥饿有什么区别">Java中的死锁、活锁、饥饿有什么区别</h3>
<p>活锁：任务或者执行者没有被阻塞，由于某些条件没有被满足，导致线程一直重复尝试、失败、尝试、失败。例如，线程1和线程2都需要获取一个资源，但他们同时让其他线程先获取该资源，两个线程一直谦让，最后都无法获取</p>
<p>活锁和死锁的区别：</p>
<ul>
<li>活锁是在不断地尝试、死锁是在一直等待。</li>
<li>活锁有可能自行解开、死锁无法自行解开。</li>
</ul>
<p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。以打印机打印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。活锁就是在忙式等待条件下发生的饥饿，忙式等待就是不进入等待状态的等待。</p>
<p>产生饥饿的原因：</p>
<ul>
<li>高优先级的线程占用了低优先级线程的CPU时间</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的<code>wait()</code>方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<p>死锁、饥饿的区别：饥饿可自行解开，死锁不行。</p>
<hr>
<h3 id="为什么thread类的sleep和yield方法是静态的">为什么Thread类的sleep()和yield()方法是静态的？</h3>
<p><code>sleep()</code>和<code>yield()</code>都是需要正在执行的线程调用的，那些本来就阻塞或者等待的线程调用这个方法是无意义的，所以这两个方法是静态的。</p>
<hr>
<h3 id="线程类的构造方法-静态块是被哪个线程调用的">线程类的构造方法、静态块是被哪个线程调用的？</h3>
<p>线程类的构造方法、静态块是被<code>new</code>这个线程类所在的线程所调用的，而<code>run()</code>方法里面的代码才是被线程自身所调用的。</p>
<p>一个很经典的例子：</p>
<p>假设<code>main()</code>函数中<code>new</code>了一个线程Thread1，那么Thread1的构造方法、静态块都是<code>main</code>线程调用的，Thread1中的<code>run()</code>方法是自己调用的。</p>
<p>假设在Thread1中<code>new</code>了一个线程Thread2，那么Thread2的构造方法、静态块都是Thread1线程调用的，Thread2中的<code>run()</code>方法是自己调用的。</p>
<hr>
<h3 id="一个线程运行时异常会发生什么">一个线程运行时异常会发生什么?</h3>
<p>Java中的<code>Throwable</code>主要分为<code>Exception</code>和<code>Error</code>。<code>Exception</code>分为运行时异常和非运行时异常。运行时异常可以不进行处理，代码也能通过编译，但运行时会报错。非运行时异常必须处理，否则代码无法通过编译。</p>
<hr>
<h3 id="线程数量过多会造成什么异常">线程数量过多会造成什么异常？</h3>
<ul>
<li>消耗更多的内存和CPU</li>
<li>频繁进行上下文切换</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://chimaeras.ltd/tag/3slSISDl_/" class="tag">
                    总结
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://chimaeras.ltd/post/java8-xin-te-xing/">
                  <h3 class="post-title">
                    Java8新特性
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
